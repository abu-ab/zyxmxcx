"use strict";
var config = { version: "v2.5.0-20230101", yAxisWidth: 15, xAxisHeight: 22, padding: [10, 10, 10, 10], rotate: false, fontSize: 13, fontColor: "#666666", dataPointShape: ["circle", "circle", "circle", "circle"], color: ["#1890FF", "#91CB74", "#FAC858", "#EE6666", "#73C0DE", "#3CA272", "#FC8452", "#9A60B4", "#ea7ccc"], linearColor: ["#0EE2F8", "#2BDCA8", "#FA7D8D", "#EB88E2", "#2AE3A0", "#0EE2F8", "#EB88E2", "#6773E3", "#F78A85"], pieChartLinePadding: 15, pieChartTextPadding: 5, titleFontSize: 20, subtitleFontSize: 15, radarLabelTextMargin: 13 };
var assign = function(e, ...t12) {
  if (e == null) {
    throw new TypeError("[uCharts] Cannot convert undefined or null to object");
  }
  if (!t12 || t12.length <= 0) {
    return e;
  }
  function i(e2, a) {
    for (let t13 in a) {
      e2[t13] = e2[t13] && e2[t13].toString() === "[object Object]" ? i(e2[t13], a[t13]) : e2[t13] = a[t13];
    }
    return e2;
  }
  t12.forEach((t13) => {
    e = i(e, t13);
  });
  return e;
};
var util = { toFixed: function t(e, a) {
  a = a || 2;
  if (this.isFloat(e)) {
    e = e.toFixed(a);
  }
  return e;
}, isFloat: function t2(e) {
  return e % 1 !== 0;
}, approximatelyEqual: function t3(e, a) {
  return Math.abs(e - a) < 1e-10;
}, isSameSign: function t4(e, a) {
  return Math.abs(e) === e && Math.abs(a) === a || Math.abs(e) !== e && Math.abs(a) !== a;
}, isSameXCoordinateArea: function t5(e, a) {
  return this.isSameSign(e.x, a.x);
}, isCollision: function t6(e, a) {
  e.end = {};
  e.end.x = e.start.x + e.width;
  e.end.y = e.start.y - e.height;
  a.end = {};
  a.end.x = a.start.x + a.width;
  a.end.y = a.start.y - a.height;
  var i = a.start.x > e.end.x || a.end.x < e.start.x || a.end.y > e.start.y || a.start.y < e.end.y;
  return !i;
} };
function hexToRgb(t12, e) {
  var a = /^#?([a-f\d])([a-f\d])([a-f\d])$/i;
  var i = t12.replace(a, function(t13, e2, a2, i2) {
    return e2 + e2 + a2 + a2 + i2 + i2;
  });
  var r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(i);
  var o = parseInt(r[1], 16);
  var n = parseInt(r[2], 16);
  var l = parseInt(r[3], 16);
  return "rgba(" + o + "," + n + "," + l + "," + e + ")";
}
function findRange(t12, e, a) {
  if (isNaN(t12)) {
    throw new Error("[uCharts] series数据需为Number格式");
  }
  a = a || 10;
  e = e ? e : "upper";
  var i = 1;
  while (a < 1) {
    a *= 10;
    i *= 10;
  }
  if (e === "upper") {
    t12 = Math.ceil(t12 * i);
  } else {
    t12 = Math.floor(t12 * i);
  }
  while (t12 % a !== 0) {
    if (e === "upper") {
      if (t12 == t12 + 1) {
        break;
      }
      t12++;
    } else {
      t12--;
    }
  }
  return t12 / i;
}
function calCandleMA(o, t12, e, n) {
  let a = [];
  for (let r = 0; r < o.length; r++) {
    let i = { data: [], name: t12[r], color: e[r] };
    for (let a2 = 0, t13 = n.length; a2 < t13; a2++) {
      if (a2 < o[r]) {
        i.data.push(null);
        continue;
      }
      let e2 = 0;
      for (let t14 = 0; t14 < o[r]; t14++) {
        e2 += n[a2 - t14][1];
      }
      i.data.push(+(e2 / o[r]).toFixed(3));
    }
    a.push(i);
  }
  return a;
}
function calValidDistance(t12, e, a, i, r) {
  var o = r.width - r.area[1] - r.area[3];
  var n = a.eachSpacing * (r.chartData.xAxisData.xAxisPoints.length - 1);
  if (r.type == "mount" && r.extra && r.extra.mount && r.extra.mount.widthRatio && r.extra.mount.widthRatio > 1) {
    if (r.extra.mount.widthRatio > 2)
      r.extra.mount.widthRatio = 2;
    n += (r.extra.mount.widthRatio - 1) * a.eachSpacing;
  }
  var l = e;
  if (e >= 0) {
    l = 0;
    t12.uevent.trigger("scrollLeft");
    t12.scrollOption.position = "left";
    r.xAxis.scrollPosition = "left";
  } else if (Math.abs(e) >= n - o) {
    l = o - n;
    t12.uevent.trigger("scrollRight");
    t12.scrollOption.position = "right";
    r.xAxis.scrollPosition = "right";
  } else {
    t12.scrollOption.position = e;
    r.xAxis.scrollPosition = e;
  }
  return l;
}
function isInAngleRange(t12, e, a) {
  function i(t13) {
    while (t13 < 0) {
      t13 += 2 * Math.PI;
    }
    while (t13 > 2 * Math.PI) {
      t13 -= 2 * Math.PI;
    }
    return t13;
  }
  t12 = i(t12);
  e = i(e);
  a = i(a);
  if (e > a) {
    a += 2 * Math.PI;
    if (t12 < e) {
      t12 += 2 * Math.PI;
    }
  }
  return t12 >= e && t12 <= a;
}
function createCurveControlPoints(t12, e) {
  function a(t13, e2) {
    if (t13[e2 - 1] && t13[e2 + 1]) {
      return t13[e2].y >= Math.max(t13[e2 - 1].y, t13[e2 + 1].y) || t13[e2].y <= Math.min(t13[e2 - 1].y, t13[e2 + 1].y);
    } else {
      return false;
    }
  }
  function c(t13, e2) {
    if (t13[e2 - 1] && t13[e2 + 1]) {
      return t13[e2].x >= Math.max(t13[e2 - 1].x, t13[e2 + 1].x) || t13[e2].x <= Math.min(t13[e2 - 1].x, t13[e2 + 1].x);
    } else {
      return false;
    }
  }
  var i = 0.2;
  var r = 0.2;
  var o = null;
  var n = null;
  var l = null;
  var s = null;
  if (e < 1) {
    o = t12[0].x + (t12[1].x - t12[0].x) * i;
    n = t12[0].y + (t12[1].y - t12[0].y) * i;
  } else {
    o = t12[e].x + (t12[e + 1].x - t12[e - 1].x) * i;
    n = t12[e].y + (t12[e + 1].y - t12[e - 1].y) * i;
  }
  if (e > t12.length - 3) {
    var h = t12.length - 1;
    l = t12[h].x - (t12[h].x - t12[h - 1].x) * r;
    s = t12[h].y - (t12[h].y - t12[h - 1].y) * r;
  } else {
    l = t12[e + 1].x - (t12[e + 2].x - t12[e].x) * r;
    s = t12[e + 1].y - (t12[e + 2].y - t12[e].y) * r;
  }
  if (a(t12, e + 1)) {
    s = t12[e + 1].y;
  }
  if (a(t12, e)) {
    n = t12[e].y;
  }
  if (c(t12, e + 1)) {
    l = t12[e + 1].x;
  }
  if (c(t12, e)) {
    o = t12[e].x;
  }
  if (n >= Math.max(t12[e].y, t12[e + 1].y) || n <= Math.min(t12[e].y, t12[e + 1].y)) {
    n = t12[e].y;
  }
  if (s >= Math.max(t12[e].y, t12[e + 1].y) || s <= Math.min(t12[e].y, t12[e + 1].y)) {
    s = t12[e + 1].y;
  }
  if (o >= Math.max(t12[e].x, t12[e + 1].x) || o <= Math.min(t12[e].x, t12[e + 1].x)) {
    o = t12[e].x;
  }
  if (l >= Math.max(t12[e].x, t12[e + 1].x) || l <= Math.min(t12[e].x, t12[e + 1].x)) {
    l = t12[e + 1].x;
  }
  return { ctrA: { x: o, y: n }, ctrB: { x: l, y: s } };
}
function convertCoordinateOrigin(t12, e, a) {
  return { x: a.x + t12, y: a.y - e };
}
function avoidCollision(t12, e) {
  if (e) {
    while (util.isCollision(t12, e)) {
      if (t12.start.x > 0) {
        t12.start.y--;
      } else if (t12.start.x < 0) {
        t12.start.y++;
      } else {
        if (t12.start.y > 0) {
          t12.start.y++;
        } else {
          t12.start.y--;
        }
      }
    }
  }
  return t12;
}
function fixPieSeries(e, a, t12) {
  let i = [];
  if (e.length > 0 && e[0].data.constructor.toString().indexOf("Array") > -1) {
    a._pieSeries_ = e;
    let t13 = e[0].data;
    for (var r = 0; r < t13.length; r++) {
      t13[r].formatter = e[0].formatter;
      t13[r].data = t13[r].value;
      i.push(t13[r]);
    }
    a.series = i;
  } else {
    i = e;
  }
  return i;
}
function fillSeries(e, a, i) {
  var r = 0;
  for (var o = 0; o < e.length; o++) {
    let t12 = e[o];
    if (!t12.color) {
      t12.color = i.color[r];
      r = (r + 1) % i.color.length;
    }
    if (!t12.linearIndex) {
      t12.linearIndex = o;
    }
    if (!t12.index) {
      t12.index = 0;
    }
    if (!t12.type) {
      t12.type = a.type;
    }
    if (typeof t12.show == "undefined") {
      t12.show = true;
    }
    if (!t12.type) {
      t12.type = a.type;
    }
    if (!t12.pointShape) {
      t12.pointShape = "circle";
    }
    if (!t12.legendShape) {
      switch (t12.type) {
        case "line":
          t12.legendShape = "line";
          break;
        case "column":
        case "bar":
          t12.legendShape = "rect";
          break;
        case "area":
        case "mount":
          t12.legendShape = "triangle";
          break;
        default:
          t12.legendShape = "circle";
      }
    }
  }
  return e;
}
function fillCustomColor(t12, e, a, i) {
  var r = e || [];
  if (t12 == "custom" && r.length == 0) {
    r = i.linearColor;
  }
  if (t12 == "custom" && r.length < a.length) {
    let t13 = a.length - r.length;
    for (var o = 0; o < t13; o++) {
      r.push(i.linearColor[(o + 1) % i.linearColor.length]);
    }
  }
  return r;
}
function getDataRange(t12, e) {
  var a = 0;
  var i = e - t12;
  if (i >= 1e4) {
    a = 1e3;
  } else if (i >= 1e3) {
    a = 100;
  } else if (i >= 100) {
    a = 10;
  } else if (i >= 10) {
    a = 5;
  } else if (i >= 1) {
    a = 1;
  } else if (i >= 0.1) {
    a = 0.1;
  } else if (i >= 0.01) {
    a = 0.01;
  } else if (i >= 1e-3) {
    a = 1e-3;
  } else if (i >= 1e-4) {
    a = 1e-4;
  } else if (i >= 1e-5) {
    a = 1e-5;
  } else {
    a = 1e-6;
  }
  return { minRange: findRange(t12, "lower", a), maxRange: findRange(e, "upper", a) };
}
function measureText(a, t12, e) {
  var i = 0;
  a = String(a);
  e = false;
  if (e !== false && e !== void 0 && e.setFontSize && e.measureText) {
    e.setFontSize(t12);
    return e.measureText(a).width;
  } else {
    var a = a.split("");
    for (let e2 = 0; e2 < a.length; e2++) {
      let t13 = a[e2];
      if (/[a-zA-Z]/.test(t13)) {
        i += 7;
      } else if (/[0-9]/.test(t13)) {
        i += 5.5;
      } else if (/\./.test(t13)) {
        i += 2.7;
      } else if (/-/.test(t13)) {
        i += 3.25;
      } else if (/:/.test(t13)) {
        i += 2.5;
      } else if (/[\u4e00-\u9fa5]/.test(t13)) {
        i += 10;
      } else if (/\(|\)/.test(t13)) {
        i += 3.73;
      } else if (/\s/.test(t13)) {
        i += 2.5;
      } else if (/%/.test(t13)) {
        i += 8;
      } else {
        i += 10;
      }
    }
    return i * t12 / 10;
  }
}
function dataCombine(t12) {
  return t12.reduce(function(t13, e) {
    return (t13.data ? t13.data : t13).concat(e.data);
  }, []);
}
function dataCombineStack(t12, e) {
  var a = new Array(e);
  for (var i = 0; i < a.length; i++) {
    a[i] = 0;
  }
  for (var r = 0; r < t12.length; r++) {
    for (var i = 0; i < a.length; i++) {
      a[i] += t12[r].data[i];
    }
  }
  return t12.reduce(function(t13, e2) {
    return (t13.data ? t13.data : t13).concat(e2.data).concat(a);
  }, []);
}
function getTouches(t12, e, a) {
  let i, r;
  if (t12.clientX) {
    if (e.rotate) {
      r = e.height - t12.clientX * e.pix;
      i = (t12.pageY - a.currentTarget.offsetTop - e.height / e.pix / 2 * (e.pix - 1)) * e.pix;
    } else {
      i = t12.clientX * e.pix;
      r = (t12.pageY - a.currentTarget.offsetTop - e.height / e.pix / 2 * (e.pix - 1)) * e.pix;
    }
  } else {
    if (e.rotate) {
      r = e.height - t12.x * e.pix;
      i = t12.y * e.pix;
    } else {
      i = t12.x * e.pix;
      r = t12.y * e.pix;
    }
  }
  return { x: i, y: r };
}
function getSeriesDataItem(e, i, a) {
  var r = [];
  var o = [];
  var n = i.constructor.toString().indexOf("Array") > -1;
  if (n) {
    let t12 = filterSeries(e);
    for (var l = 0; l < a.length; l++) {
      o.push(t12[a[l]]);
    }
  } else {
    o = e;
  }
  for (let t12 = 0; t12 < o.length; t12++) {
    let e2 = o[t12];
    let a2 = -1;
    if (n) {
      a2 = i[t12];
    } else {
      a2 = i;
    }
    if (e2.data[a2] !== null && typeof e2.data[a2] !== "undefined" && e2.show) {
      let t13 = {};
      t13.color = e2.color;
      t13.type = e2.type;
      t13.style = e2.style;
      t13.pointShape = e2.pointShape;
      t13.disableLegend = e2.disableLegend;
      t13.legendShape = e2.legendShape;
      t13.name = e2.name;
      t13.show = e2.show;
      t13.data = e2.formatter ? e2.formatter(e2.data[a2]) : e2.data[a2];
      r.push(t13);
    }
  }
  return r;
}
function getMaxTextListLength(t12, e, a) {
  var i = t12.map(function(t13) {
    return measureText(t13, e, a);
  });
  return Math.max.apply(null, i);
}
function getRadarCoordinateSeries(t12) {
  var e = 2 * Math.PI / t12;
  var a = [];
  for (var i = 0; i < t12; i++) {
    a.push(e * i);
  }
  return a.map(function(t13) {
    return -1 * t13 + Math.PI / 2;
  });
}
function getToolTipData(t12, a, i, r, o) {
  var n = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : {};
  var l = a.chartData.calPoints ? a.chartData.calPoints : [];
  let s = {};
  if (r.length > 0) {
    let e2 = [];
    for (let t13 = 0; t13 < r.length; t13++) {
      e2.push(l[r[t13]]);
    }
    s = e2[0][i[0]];
  } else {
    for (let t13 = 0; t13 < l.length; t13++) {
      if (l[t13][i]) {
        s = l[t13][i];
        break;
      }
    }
  }
  var e = t12.map(function(t13) {
    let e2 = null;
    if (a.categories && a.categories.length > 0) {
      e2 = o[i];
    }
    return { text: n.formatter ? n.formatter(t13, e2, i, a) : t13.name + ": " + t13.data, color: t13.color, legendShape: a.extra.tooltip.legendShape == "auto" ? t13.legendShape : a.extra.tooltip.legendShape };
  });
  var h = { x: Math.round(s.x), y: Math.round(s.y) };
  return { textList: e, offset: h };
}
function getMixToolTipData(t12, e, a, i) {
  var r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : {};
  var o = e.chartData.xAxisPoints[a] + e.chartData.eachSpacing / 2;
  var n = t12.map(function(t13) {
    return { text: r.formatter ? r.formatter(t13, i[a], a, e) : t13.name + ": " + t13.data, color: t13.color, disableLegend: t13.disableLegend ? true : false, legendShape: e.extra.tooltip.legendShape == "auto" ? t13.legendShape : e.extra.tooltip.legendShape };
  });
  n = n.filter(function(t13) {
    if (t13.disableLegend !== true) {
      return t13;
    }
  });
  var l = { x: Math.round(o), y: 0 };
  return { textList: n, offset: l };
}
function getCandleToolTipData(o, e, n, l, i, t12) {
  var a = n.chartData.calPoints;
  let s = t12.color.upFill;
  let h = t12.color.downFill;
  let c = [s, s, h, s];
  var d = [];
  e.map(function(t13) {
    if (l == 0) {
      if (t13.data[1] - t13.data[0] < 0) {
        c[1] = h;
      } else {
        c[1] = s;
      }
    } else {
      if (t13.data[0] < o[l - 1][1]) {
        c[0] = h;
      }
      if (t13.data[1] < t13.data[0]) {
        c[1] = h;
      }
      if (t13.data[2] > o[l - 1][1]) {
        c[2] = s;
      }
      if (t13.data[3] < o[l - 1][1]) {
        c[3] = h;
      }
    }
    let e2 = { text: "开盘：" + t13.data[0], color: c[0], legendShape: n.extra.tooltip.legendShape == "auto" ? t13.legendShape : n.extra.tooltip.legendShape };
    let a2 = { text: "收盘：" + t13.data[1], color: c[1], legendShape: n.extra.tooltip.legendShape == "auto" ? t13.legendShape : n.extra.tooltip.legendShape };
    let i2 = { text: "最低：" + t13.data[2], color: c[2], legendShape: n.extra.tooltip.legendShape == "auto" ? t13.legendShape : n.extra.tooltip.legendShape };
    let r = { text: "最高：" + t13.data[3], color: c[3], legendShape: n.extra.tooltip.legendShape == "auto" ? t13.legendShape : n.extra.tooltip.legendShape };
    d.push(e2, a2, i2, r);
  });
  var x = [];
  var f = { x: 0, y: 0 };
  for (let e2 = 0; e2 < a.length; e2++) {
    let t13 = a[e2];
    if (typeof t13[l] !== "undefined" && t13[l] !== null) {
      x.push(t13[l]);
    }
  }
  f.x = Math.round(x[0][0].x);
  return { textList: d, offset: f };
}
function filterSeries(e) {
  let a = [];
  for (let t12 = 0; t12 < e.length; t12++) {
    if (e[t12].show == true) {
      a.push(e[t12]);
    }
  }
  return a;
}
function findCurrentIndex(o, n, e, t12) {
  var a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  var l = { index: -1, group: [] };
  var i = e.chartData.eachSpacing / 2;
  let r = [];
  if (n && n.length > 0) {
    if (!e.categories) {
      i = 0;
    } else {
      for (let t13 = 1; t13 < e.chartData.xAxisPoints.length; t13++) {
        r.push(e.chartData.xAxisPoints[t13] - i);
      }
      if ((e.type == "line" || e.type == "area") && e.xAxis.boundaryGap == "justify") {
        r = e.chartData.xAxisPoints;
      }
    }
    if (isInExactChartArea(o, e)) {
      if (!e.categories) {
        let a2 = Array(n.length);
        for (let e3 = 0; e3 < n.length; e3++) {
          a2[e3] = Array(n[e3].length);
          for (let t13 = 0; t13 < n[e3].length; t13++) {
            a2[e3][t13] = Math.abs(n[e3][t13].x - o.x);
          }
        }
        let e2 = Array(a2.length);
        let i2 = Array(a2.length);
        for (let t13 = 0; t13 < a2.length; t13++) {
          e2[t13] = Math.min.apply(null, a2[t13]);
          i2[t13] = a2[t13].indexOf(e2[t13]);
        }
        let r2 = Math.min.apply(null, e2);
        l.index = [];
        for (let t13 = 0; t13 < e2.length; t13++) {
          if (e2[t13] == r2) {
            l.group.push(t13);
            l.index.push(i2[t13]);
          }
        }
      } else {
        r.forEach(function(t13, e2) {
          if (o.x + a + i > t13) {
            l.index = e2;
          }
        });
      }
    }
  }
  return l;
}
function findBarChartCurrentIndex(a, t12, e, i) {
  var r = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 0;
  var o = { index: -1, group: [] };
  var n = e.chartData.eachSpacing / 2;
  let l = e.chartData.yAxisPoints;
  if (t12 && t12.length > 0) {
    if (isInExactChartArea(a, e)) {
      l.forEach(function(t13, e2) {
        if (a.y + r + n > t13) {
          o.index = e2;
        }
      });
    }
  }
  return o;
}
function findLegendIndex(o, t12, e) {
  let n = -1;
  let l = 0;
  if (isInExactLegendArea(o, t12.area)) {
    let i = t12.points;
    let r = -1;
    for (let t13 = 0, e2 = i.length; t13 < e2; t13++) {
      let a = i[t13];
      for (let e3 = 0; e3 < a.length; e3++) {
        r += 1;
        let t14 = a[e3]["area"];
        if (t14 && o.x > t14[0] - l && o.x < t14[2] + l && o.y > t14[1] - l && o.y < t14[3] + l) {
          n = r;
          break;
        }
      }
    }
    return n;
  }
  return n;
}
function isInExactLegendArea(t12, e) {
  return t12.x > e.start.x && t12.x < e.end.x && t12.y > e.start.y && t12.y < e.end.y;
}
function isInExactChartArea(t12, e, a) {
  return t12.x <= e.width - e.area[1] + 10 && t12.x >= e.area[3] - 10 && t12.y >= e.area[0] && t12.y <= e.height - e.area[2];
}
function findRadarChartCurrentIndex(t12, e, a) {
  var r = 2 * Math.PI / a;
  var o = -1;
  if (isInExactPieChartArea(t12, e.center, e.radius)) {
    var n = function t13(e2) {
      if (e2 < 0) {
        e2 += 2 * Math.PI;
      }
      if (e2 > 2 * Math.PI) {
        e2 -= 2 * Math.PI;
      }
      return e2;
    };
    var l = Math.atan2(e.center.y - t12.y, t12.x - e.center.x);
    l = -1 * l;
    if (l < 0) {
      l += 2 * Math.PI;
    }
    var i = e.angleList.map(function(t13) {
      t13 = n(-1 * t13);
      return t13;
    });
    i.forEach(function(t13, e2) {
      var a2 = n(t13 - r / 2);
      var i2 = n(t13 + r / 2);
      if (i2 < a2) {
        i2 += 2 * Math.PI;
      }
      if (l >= a2 && l <= i2 || l + 2 * Math.PI >= a2 && l + 2 * Math.PI <= i2) {
        o = e2;
      }
    });
  }
  return o;
}
function findFunnelChartCurrentIndex(t12, e) {
  var a = -1;
  for (var i = 0, r = e.series.length; i < r; i++) {
    var o = e.series[i];
    if (t12.x > o.funnelArea[0] && t12.x < o.funnelArea[2] && t12.y > o.funnelArea[1] && t12.y < o.funnelArea[3]) {
      a = i;
      break;
    }
  }
  return a;
}
function findWordChartCurrentIndex(t12, e) {
  var a = -1;
  for (var i = 0, r = e.length; i < r; i++) {
    var o = e[i];
    if (t12.x > o.area[0] && t12.x < o.area[2] && t12.y > o.area[1] && t12.y < o.area[3]) {
      a = i;
      break;
    }
  }
  return a;
}
function findMapChartCurrentIndex(t12, e) {
  var a = -1;
  var i = e.chartData.mapData;
  var r = e.series;
  var o = pointToCoordinate(t12.y, t12.x, i.bounds, i.scale, i.xoffset, i.yoffset);
  var n = [o.x, o.y];
  for (var l = 0, s = r.length; l < s; l++) {
    var h = r[l].geometry.coordinates;
    if (isPoiWithinPoly(n, h, e.chartData.mapData.mercator)) {
      a = l;
      break;
    }
  }
  return a;
}
function findRoseChartCurrentIndex(t12, e, a) {
  var i = -1;
  var r = getRoseDataPoints(a._series_, a.extra.rose.type, e.radius, e.radius);
  if (e && e.center && isInExactPieChartArea(t12, e.center, e.radius)) {
    var o = Math.atan2(e.center.y - t12.y, t12.x - e.center.x);
    o = -o;
    if (a.extra.rose && a.extra.rose.offsetAngle) {
      o = o - a.extra.rose.offsetAngle * Math.PI / 180;
    }
    for (var n = 0, l = r.length; n < l; n++) {
      if (isInAngleRange(o, r[n]._start_, r[n]._start_ + r[n]._rose_proportion_ * 2 * Math.PI)) {
        i = n;
        break;
      }
    }
  }
  return i;
}
function findPieChartCurrentIndex(t12, e, a) {
  var i = -1;
  var r = getPieDataPoints(e.series);
  if (e && e.center && isInExactPieChartArea(t12, e.center, e.radius)) {
    var o = Math.atan2(e.center.y - t12.y, t12.x - e.center.x);
    o = -o;
    if (a.extra.pie && a.extra.pie.offsetAngle) {
      o = o - a.extra.pie.offsetAngle * Math.PI / 180;
    }
    if (a.extra.ring && a.extra.ring.offsetAngle) {
      o = o - a.extra.ring.offsetAngle * Math.PI / 180;
    }
    for (var n = 0, l = r.length; n < l; n++) {
      if (isInAngleRange(o, r[n]._start_, r[n]._start_ + r[n]._proportion_ * 2 * Math.PI)) {
        i = n;
        break;
      }
    }
  }
  return i;
}
function isInExactPieChartArea(t12, e, a) {
  return Math.pow(t12.x - e.x, 2) + Math.pow(t12.y - e.y, 2) <= Math.pow(a, 2);
}
function splitPoints(t12, a) {
  var i = [];
  var r = [];
  t12.forEach(function(t13, e) {
    if (a.connectNulls) {
      if (t13 !== null) {
        r.push(t13);
      }
    } else {
      if (t13 !== null) {
        r.push(t13);
      } else {
        if (r.length) {
          i.push(r);
        }
        r = [];
      }
    }
  });
  if (r.length) {
    i.push(r);
  }
  return i;
}
function calLegendData(l, s, e, t12, h) {
  let c = { area: { start: { x: 0, y: 0 }, end: { x: 0, y: 0 }, width: 0, height: 0, wholeWidth: 0, wholeHeight: 0 }, points: [], widthArr: [], heightArr: [] };
  if (s.legend.show === false) {
    t12.legendData = c;
    return c;
  }
  let d = s.legend.padding * s.pix;
  let x = s.legend.margin * s.pix;
  let f = s.legend.fontSize ? s.legend.fontSize * s.pix : e.fontSize;
  let p = 15 * s.pix;
  let g = 5 * s.pix;
  let u = Math.max(s.legend.lineHeight * s.pix, f);
  if (s.legend.position == "top" || s.legend.position == "bottom") {
    let i = [];
    let r = 0;
    let o = [];
    let n = [];
    for (let a = 0; a < l.length; a++) {
      let t13 = l[a];
      const y = t13.legendText ? t13.legendText : t13.name;
      let e2 = p + g + measureText(y || "undefined", f, h) + s.legend.itemGap * s.pix;
      if (r + e2 > s.width - s.area[1] - s.area[3]) {
        i.push(n);
        o.push(r - s.legend.itemGap * s.pix);
        r = e2;
        n = [t13];
      } else {
        r += e2;
        n.push(t13);
      }
    }
    if (n.length) {
      i.push(n);
      o.push(r - s.legend.itemGap * s.pix);
      c.widthArr = o;
      let t13 = Math.max.apply(null, o);
      switch (s.legend.float) {
        case "left":
          c.area.start.x = s.area[3];
          c.area.end.x = s.area[3] + t13 + 2 * d;
          break;
        case "right":
          c.area.start.x = s.width - s.area[1] - t13 - 2 * d;
          c.area.end.x = s.width - s.area[1];
          break;
        default:
          c.area.start.x = (s.width - t13) / 2 - d;
          c.area.end.x = (s.width + t13) / 2 + d;
      }
      c.area.width = t13 + 2 * d;
      c.area.wholeWidth = t13 + 2 * d;
      c.area.height = i.length * u + 2 * d;
      c.area.wholeHeight = i.length * u + 2 * d + 2 * x;
      c.points = i;
    }
  } else {
    let t13 = l.length;
    let e2 = s.height - s.area[0] - s.area[2] - 2 * x - 2 * d;
    let a = Math.min(Math.floor(e2 / u), t13);
    c.area.height = a * u + d * 2;
    c.area.wholeHeight = a * u + d * 2;
    switch (s.legend.float) {
      case "top":
        c.area.start.y = s.area[0] + x;
        c.area.end.y = s.area[0] + x + c.area.height;
        break;
      case "bottom":
        c.area.start.y = s.height - s.area[2] - x - c.area.height;
        c.area.end.y = s.height - s.area[2] - x;
        break;
      default:
        c.area.start.y = (s.height - c.area.height) / 2;
        c.area.end.y = (s.height + c.area.height) / 2;
    }
    let i = t13 % a === 0 ? t13 / a : Math.floor(t13 / a + 1);
    let r = [];
    for (let e3 = 0; e3 < i; e3++) {
      let t14 = l.slice(e3 * a, e3 * a + a);
      r.push(t14);
    }
    c.points = r;
    if (r.length) {
      for (let t14 = 0; t14 < r.length; t14++) {
        let a2 = r[t14];
        let i2 = 0;
        for (let e4 = 0; e4 < a2.length; e4++) {
          let t15 = p + g + measureText(a2[e4].name || "undefined", f, h) + s.legend.itemGap * s.pix;
          if (t15 > i2) {
            i2 = t15;
          }
        }
        c.widthArr.push(i2);
        c.heightArr.push(a2.length * u + d * 2);
      }
      let e3 = 0;
      for (let t14 = 0; t14 < c.widthArr.length; t14++) {
        e3 += c.widthArr[t14];
      }
      c.area.width = e3 - s.legend.itemGap * s.pix + 2 * d;
      c.area.wholeWidth = c.area.width + d;
    }
  }
  switch (s.legend.position) {
    case "top":
      c.area.start.y = s.area[0] + x;
      c.area.end.y = s.area[0] + x + c.area.height;
      break;
    case "bottom":
      c.area.start.y = s.height - s.area[2] - c.area.height - x;
      c.area.end.y = s.height - s.area[2] - x;
      break;
    case "left":
      c.area.start.x = s.area[3];
      c.area.end.x = s.area[3] + c.area.width;
      break;
    case "right":
      c.area.start.x = s.width - s.area[1] - c.area.width;
      c.area.end.x = s.width - s.area[1];
      break;
  }
  t12.legendData = c;
  return c;
}
function calCategoriesData(t12, i, e, a, r) {
  var o = { angle: 0, xAxisHeight: i.xAxis.lineHeight * i.pix + i.xAxis.marginTop * i.pix };
  var n = i.xAxis.fontSize * i.pix;
  var l = t12.map(function(t13, e2) {
    var a2 = i.xAxis.formatter ? i.xAxis.formatter(t13, e2, i) : t13;
    return measureText(String(a2), n, r);
  });
  var s = Math.max.apply(this, l);
  if (i.xAxis.rotateLabel == true) {
    o.angle = i.xAxis.rotateAngle * Math.PI / 180;
    let t13 = i.xAxis.marginTop * i.pix * 2 + Math.abs(s * Math.sin(o.angle));
    t13 = t13 < n + i.xAxis.marginTop * i.pix * 2 ? t13 + i.xAxis.marginTop * i.pix * 2 : t13;
    o.xAxisHeight = t13;
  }
  if (i.enableScroll && i.xAxis.scrollShow) {
    o.xAxisHeight += 6 * i.pix;
  }
  if (i.xAxis.disabled) {
    o.xAxisHeight = 0;
  }
  return o;
}
function getXAxisTextList(t12, e, h, c) {
  var a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : -1;
  var i;
  if (c == "stack") {
    i = dataCombineStack(t12, e.categories.length);
  } else {
    i = dataCombine(t12);
  }
  var r = [];
  i = i.filter(function(t13) {
    if (typeof t13 === "object" && t13 !== null) {
      if (t13.constructor.toString().indexOf("Array") > -1) {
        return t13 !== null;
      } else {
        return t13.value !== null;
      }
    } else {
      return t13 !== null;
    }
  });
  i.map(function(t13) {
    if (typeof t13 === "object") {
      if (t13.constructor.toString().indexOf("Array") > -1) {
        if (e.type == "candle") {
          t13.map(function(t14) {
            r.push(t14);
          });
        } else {
          r.push(t13[0]);
        }
      } else {
        r.push(t13.value);
      }
    } else {
      r.push(t13);
    }
  });
  var o = 0;
  var n = 0;
  if (r.length > 0) {
    o = Math.min.apply(this, r);
    n = Math.max.apply(this, r);
  }
  if (a > -1) {
    if (typeof e.xAxis.data[a].min === "number") {
      o = Math.min(e.xAxis.data[a].min, o);
    }
    if (typeof e.xAxis.data[a].max === "number") {
      n = Math.max(e.xAxis.data[a].max, n);
    }
  } else {
    if (typeof e.xAxis.min === "number") {
      o = Math.min(e.xAxis.min, o);
    }
    if (typeof e.xAxis.max === "number") {
      n = Math.max(e.xAxis.max, n);
    }
  }
  if (o === n) {
    var d = n || 10;
    n += d;
  }
  var l = o;
  var x = n;
  var f = [];
  var p = (x - l) / e.xAxis.splitNumber;
  for (var s = 0; s <= e.xAxis.splitNumber; s++) {
    f.push(l + p * s);
  }
  return f;
}
function calXAxisData(t12, e, a, i) {
  var r = assign({}, { type: "" }, e.extra.bar);
  var o = { angle: 0, xAxisHeight: e.xAxis.lineHeight * e.pix + e.xAxis.marginTop * e.pix };
  o.ranges = getXAxisTextList(t12, e, a, r.type);
  o.rangesFormat = o.ranges.map(function(t13) {
    t13 = util.toFixed(t13, 2);
    return t13;
  });
  var n = o.ranges.map(function(t13) {
    t13 = util.toFixed(t13, 2);
    return t13;
  });
  o = Object.assign(o, getXAxisPoints(n, e));
  o.eachSpacing;
  n.map(function(t13) {
    return measureText(t13, e.xAxis.fontSize * e.pix, i);
  });
  if (e.xAxis.disabled === true) {
    o.xAxisHeight = 0;
  }
  return o;
}
function getRadarDataPoints(r, o, n, a, t12) {
  var l = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1;
  var e = t12.extra.radar || {};
  e.max = e.max || 0;
  var s = Math.max(e.max, Math.max.apply(null, dataCombine(a)));
  var h = [];
  for (let e2 = 0; e2 < a.length; e2++) {
    let t13 = a[e2];
    let i = {};
    i.color = t13.color;
    i.legendShape = t13.legendShape;
    i.pointShape = t13.pointShape;
    i.data = [];
    t13.data.forEach(function(t14, e3) {
      let a2 = {};
      a2.angle = r[e3];
      a2.proportion = t14 / s;
      a2.value = t14;
      a2.position = convertCoordinateOrigin(n * a2.proportion * l * Math.cos(a2.angle), n * a2.proportion * l * Math.sin(a2.angle), o);
      i.data.push(a2);
    });
    h.push(i);
  }
  return h;
}
function getPieDataPoints(a, i) {
  var r = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  var o = 0;
  var n = 0;
  for (let e = 0; e < a.length; e++) {
    let t12 = a[e];
    t12.data = t12.data === null ? 0 : t12.data;
    o += t12.data;
  }
  for (let e = 0; e < a.length; e++) {
    let t12 = a[e];
    t12.data = t12.data === null ? 0 : t12.data;
    if (o === 0) {
      t12._proportion_ = 1 / a.length * r;
    } else {
      t12._proportion_ = t12.data / o * r;
    }
    t12._radius_ = i;
  }
  for (let e = 0; e < a.length; e++) {
    let t12 = a[e];
    t12._start_ = n;
    n += 2 * t12._proportion_ * Math.PI;
  }
  return a;
}
function getFunnelDataPoints(e, a, i, r) {
  var o = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1;
  for (let t12 = 0; t12 < e.length; t12++) {
    if (i.type == "funnel") {
      e[t12].radius = e[t12].data / e[0].data * a * o;
    } else {
      e[t12].radius = r * (e.length - t12) / (r * e.length) * a * o;
    }
    e[t12]._proportion_ = e[t12].data / e[0].data;
  }
  return e;
}
function getRoseDataPoints(a, i, r, o) {
  var n = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1;
  var l = 0;
  var s = 0;
  var h = [];
  for (let e = 0; e < a.length; e++) {
    let t12 = a[e];
    t12.data = t12.data === null ? 0 : t12.data;
    l += t12.data;
    h.push(t12.data);
  }
  var c = Math.min.apply(null, h);
  var d = Math.max.apply(null, h);
  var x = o - r;
  for (let e = 0; e < a.length; e++) {
    let t12 = a[e];
    t12.data = t12.data === null ? 0 : t12.data;
    if (l === 0) {
      t12._proportion_ = 1 / a.length * n;
      t12._rose_proportion_ = 1 / a.length * n;
    } else {
      t12._proportion_ = t12.data / l * n;
      if (i == "area") {
        t12._rose_proportion_ = 1 / a.length * n;
      } else {
        t12._rose_proportion_ = t12.data / l * n;
      }
    }
    t12._radius_ = r + x * ((t12.data - c) / (d - c)) || o;
  }
  for (let e = 0; e < a.length; e++) {
    let t12 = a[e];
    t12._start_ = s;
    s += 2 * t12._rose_proportion_ * Math.PI;
  }
  return a;
}
function getArcbarDataPoints(i, r) {
  var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  if (o == 1) {
    o = 0.999999;
  }
  for (let a = 0; a < i.length; a++) {
    let t12 = i[a];
    t12.data = t12.data === null ? 0 : t12.data;
    let e;
    if (r.type == "circle") {
      e = 2;
    } else {
      if (r.direction == "ccw") {
        if (r.startAngle < r.endAngle) {
          e = 2 + r.startAngle - r.endAngle;
        } else {
          e = r.startAngle - r.endAngle;
        }
      } else {
        if (r.endAngle < r.startAngle) {
          e = 2 + r.endAngle - r.startAngle;
        } else {
          e = r.startAngle - r.endAngle;
        }
      }
    }
    t12._proportion_ = e * t12.data * o + r.startAngle;
    if (r.direction == "ccw") {
      t12._proportion_ = r.startAngle - e * t12.data * o;
    }
    if (t12._proportion_ >= 2) {
      t12._proportion_ = t12._proportion_ % 2;
    }
  }
  return i;
}
function getGaugeArcbarDataPoints(i, r) {
  var o = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : 1;
  if (o == 1) {
    o = 0.999999;
  }
  for (let a = 0; a < i.length; a++) {
    let t12 = i[a];
    t12.data = t12.data === null ? 0 : t12.data;
    let e;
    if (r.type == "circle") {
      e = 2;
    } else {
      if (r.endAngle < r.startAngle) {
        e = 2 + r.endAngle - r.startAngle;
      } else {
        e = r.startAngle - r.endAngle;
      }
    }
    t12._proportion_ = e * t12.data * o + r.startAngle;
    if (t12._proportion_ >= 2) {
      t12._proportion_ = t12._proportion_ % 2;
    }
  }
  return i;
}
function getGaugeAxisPoints(e, a, t12) {
  let i;
  if (t12 < a) {
    i = 2 + t12 - a;
  } else {
    i = a - t12;
  }
  let r = a;
  for (let t13 = 0; t13 < e.length; t13++) {
    e[t13].value = e[t13].value === null ? 0 : e[t13].value;
    e[t13]._startAngle_ = r;
    e[t13]._endAngle_ = i * e[t13].value + a;
    if (e[t13]._endAngle_ >= 2) {
      e[t13]._endAngle_ = e[t13]._endAngle_ % 2;
    }
    r = e[t13]._endAngle_;
  }
  return e;
}
function getGaugeDataPoints(i, r, o) {
  let n = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : 1;
  for (let a = 0; a < i.length; a++) {
    let e = i[a];
    e.data = e.data === null ? 0 : e.data;
    if (o.pointer.color == "auto") {
      for (let t13 = 0; t13 < r.length; t13++) {
        if (e.data <= r[t13].value) {
          e.color = r[t13].color;
          break;
        }
      }
    } else {
      e.color = o.pointer.color;
    }
    let t12;
    if (o.endAngle < o.startAngle) {
      t12 = 2 + o.endAngle - o.startAngle;
    } else {
      t12 = o.startAngle - o.endAngle;
    }
    e._endAngle_ = t12 * e.data + o.startAngle;
    e._oldAngle_ = o.oldAngle;
    if (o.oldAngle < o.endAngle) {
      e._oldAngle_ += 2;
    }
    if (e.data >= o.oldData) {
      e._proportion_ = (e._endAngle_ - e._oldAngle_) * n + o.oldAngle;
    } else {
      e._proportion_ = e._oldAngle_ - (e._oldAngle_ - e._endAngle_) * n;
    }
    if (e._proportion_ >= 2) {
      e._proportion_ = e._proportion_ % 2;
    }
  }
  return i;
}
function getPieTextMaxLength(i, r, o, n) {
  i = getPieDataPoints(i);
  let l = 0;
  for (let a = 0; a < i.length; a++) {
    let t12 = i[a];
    let e = t12.formatter ? t12.formatter(+t12._proportion_.toFixed(2)) : util.toFixed(t12._proportion_ * 100) + "%";
    l = Math.max(l, measureText(e, t12.textSize * n.pix || r.fontSize, o));
  }
  return l;
}
function fixColumeData(t12, i, r, o, e, n) {
  return t12.map(function(t13) {
    if (t13 === null) {
      return null;
    }
    var e2 = 0;
    var a = 0;
    if (n.type == "mix") {
      e2 = n.extra.mix.column.seriesGap * n.pix || 0;
      a = n.extra.mix.column.categoryGap * n.pix || 0;
    } else {
      e2 = n.extra.column.seriesGap * n.pix || 0;
      a = n.extra.column.categoryGap * n.pix || 0;
    }
    e2 = Math.min(e2, i / r);
    a = Math.min(a, i / r);
    t13.width = Math.ceil((i - 2 * a - e2 * (r - 1)) / r);
    if (n.extra.mix && n.extra.mix.column.width && +n.extra.mix.column.width > 0) {
      t13.width = Math.min(t13.width, +n.extra.mix.column.width * n.pix);
    }
    if (n.extra.column && n.extra.column.width && +n.extra.column.width > 0) {
      t13.width = Math.min(t13.width, +n.extra.column.width * n.pix);
    }
    if (t13.width <= 0) {
      t13.width = 1;
    }
    t13.x += (o + 0.5 - r / 2) * (t13.width + e2);
    return t13;
  });
}
function fixBarData(t12, i, r, o, e, n) {
  return t12.map(function(t13) {
    if (t13 === null) {
      return null;
    }
    var e2 = 0;
    var a = 0;
    e2 = n.extra.bar.seriesGap * n.pix || 0;
    a = n.extra.bar.categoryGap * n.pix || 0;
    e2 = Math.min(e2, i / r);
    a = Math.min(a, i / r);
    t13.width = Math.ceil((i - 2 * a - e2 * (r - 1)) / r);
    if (n.extra.bar && n.extra.bar.width && +n.extra.bar.width > 0) {
      t13.width = Math.min(t13.width, +n.extra.bar.width * n.pix);
    }
    if (t13.width <= 0) {
      t13.width = 1;
    }
    t13.y += (o + 0.5 - r / 2) * (t13.width + e2);
    return t13;
  });
}
function fixColumeMeterData(t12, e, a, i, r, o, n) {
  var l = o.extra.column.categoryGap * o.pix || 0;
  return t12.map(function(t13) {
    if (t13 === null) {
      return null;
    }
    t13.width = e - 2 * l;
    if (o.extra.column && o.extra.column.width && +o.extra.column.width > 0) {
      t13.width = Math.min(t13.width, +o.extra.column.width * o.pix);
    }
    if (i > 0) {
      t13.width -= n;
    }
    return t13;
  });
}
function fixColumeStackData(t12, a, e, i, r, o, n) {
  var l = o.extra.column.categoryGap * o.pix || 0;
  return t12.map(function(t13, e2) {
    if (t13 === null) {
      return null;
    }
    t13.width = Math.ceil(a - 2 * l);
    if (o.extra.column && o.extra.column.width && +o.extra.column.width > 0) {
      t13.width = Math.min(t13.width, +o.extra.column.width * o.pix);
    }
    if (t13.width <= 0) {
      t13.width = 1;
    }
    return t13;
  });
}
function fixBarStackData(t12, a, e, i, r, o, n) {
  var l = o.extra.bar.categoryGap * o.pix || 0;
  return t12.map(function(t13, e2) {
    if (t13 === null) {
      return null;
    }
    t13.width = Math.ceil(a - 2 * l);
    if (o.extra.bar && o.extra.bar.width && +o.extra.bar.width > 0) {
      t13.width = Math.min(t13.width, +o.extra.bar.width * o.pix);
    }
    if (t13.width <= 0) {
      t13.width = 1;
    }
    return t13;
  });
}
function getXAxisPoints(t12, e, h) {
  var a = e.width - e.area[1] - e.area[3];
  var i = e.enableScroll ? Math.min(e.xAxis.itemCount, t12.length) : t12.length;
  if ((e.type == "line" || e.type == "area" || e.type == "scatter" || e.type == "bubble" || e.type == "bar") && i > 1 && e.xAxis.boundaryGap == "justify") {
    i -= 1;
  }
  var r = 0;
  if (e.type == "mount" && e.extra && e.extra.mount && e.extra.mount.widthRatio && e.extra.mount.widthRatio > 1) {
    if (e.extra.mount.widthRatio > 2)
      e.extra.mount.widthRatio = 2;
    r = e.extra.mount.widthRatio - 1;
    i += r;
  }
  var o = a / i;
  var n = [];
  var l = e.area[3];
  var s = e.width - e.area[1];
  t12.forEach(function(t13, e2) {
    n.push(l + r / 2 * o + e2 * o);
  });
  if (e.xAxis.boundaryGap !== "justify") {
    if (e.enableScroll === true) {
      n.push(l + r * o + t12.length * o);
    } else {
      n.push(s);
    }
  }
  return { xAxisPoints: n, startX: l, endX: s, eachSpacing: o };
}
function getCandleDataPoints(t12, l, s, h, c, d, a) {
  var x = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : 1;
  var e = [];
  var f = d.height - d.area[0] - d.area[2];
  t12.forEach(function(t13, o) {
    if (t13 === null) {
      e.push(null);
    } else {
      var n = [];
      t13.forEach(function(t14, e2) {
        var a2 = {};
        a2.x = h[o] + Math.round(c / 2);
        var i = t14.value || t14;
        var r = f * (i - l) / (s - l);
        r *= x;
        a2.y = d.height - Math.round(r) - d.area[2];
        n.push(a2);
      });
      e.push(n);
    }
  });
  return e;
}
function getDataPoints(t12, a, n, l, s, h, e) {
  var c = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : 1;
  var d = "center";
  if (h.type == "line" || h.type == "area" || h.type == "scatter" || h.type == "bubble") {
    d = h.xAxis.boundaryGap;
  }
  var x = [];
  var f = h.height - h.area[0] - h.area[2];
  var p = h.width - h.area[1] - h.area[3];
  t12.forEach(function(i, t13) {
    if (i === null) {
      x.push(null);
    } else {
      var r = {};
      r.color = i.color;
      r.x = l[t13];
      var o = i;
      if (typeof i === "object" && i !== null) {
        if (i.constructor.toString().indexOf("Array") > -1) {
          let t14, e3, a2;
          t14 = [].concat(h.chartData.xAxisData.ranges);
          e3 = t14.shift();
          a2 = t14.pop();
          o = i[1];
          r.x = h.area[3] + p * (i[0] - e3) / (a2 - e3);
          if (h.type == "bubble") {
            r.r = i[2];
            r.t = i[3];
          }
        } else {
          o = i.value;
        }
      }
      if (d == "center") {
        r.x += s / 2;
      }
      var e2 = f * (o - a) / (n - a);
      e2 *= c;
      r.y = h.height - e2 - h.area[2];
      x.push(r);
    }
  });
  return x;
}
function getLineDataPoints(t12, a, n, l, s, h, e, p, c) {
  var c = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : 1;
  var d = h.xAxis.boundaryGap;
  var x = [];
  var f = h.height - h.area[0] - h.area[2];
  var u = h.width - h.area[1] - h.area[3];
  t12.forEach(function(i, t13) {
    if (i === null) {
      x.push(null);
    } else {
      var r = {};
      r.color = i.color;
      if (p.animation == "vertical") {
        r.x = l[t13];
        var o = i;
        if (typeof i === "object" && i !== null) {
          if (i.constructor.toString().indexOf("Array") > -1) {
            let t14, e3, a2;
            t14 = [].concat(h.chartData.xAxisData.ranges);
            e3 = t14.shift();
            a2 = t14.pop();
            o = i[1];
            r.x = h.area[3] + u * (i[0] - e3) / (a2 - e3);
          } else {
            o = i.value;
          }
        }
        if (d == "center") {
          r.x += s / 2;
        }
        var e2 = f * (o - a) / (n - a);
        e2 *= c;
        r.y = h.height - e2 - h.area[2];
        x.push(r);
      } else {
        r.x = l[0] + s * t13 * c;
        var o = i;
        if (d == "center") {
          r.x += s / 2;
        }
        var e2 = f * (o - a) / (n - a);
        r.y = h.height - e2 - h.area[2];
        x.push(r);
      }
    }
  });
  return x;
}
function getColumnDataPoints(t12, a, n, l, s, h, e, i, c) {
  var c = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : 1;
  var d = [];
  var x = h.height - h.area[0] - h.area[2];
  var f = h.width - h.area[1] - h.area[3];
  t12.forEach(function(i2, t13) {
    if (i2 === null) {
      d.push(null);
    } else {
      var r = {};
      r.color = i2.color;
      r.x = l[t13];
      var o = i2;
      if (typeof i2 === "object" && i2 !== null) {
        if (i2.constructor.toString().indexOf("Array") > -1) {
          let t14, e3, a2;
          t14 = [].concat(h.chartData.xAxisData.ranges);
          e3 = t14.shift();
          a2 = t14.pop();
          o = i2[1];
          r.x = h.area[3] + f * (i2[0] - e3) / (a2 - e3);
        } else {
          o = i2.value;
        }
      }
      r.x += s / 2;
      var e2 = x * (o * c - a) / (n - a);
      r.y = h.height - e2 - h.area[2];
      d.push(r);
    }
  });
  return d;
}
function getMountDataPoints(t12, o, n, l, s, h, e, a) {
  var c = arguments.length > 8 && arguments[8] !== void 0 ? arguments[8] : 1;
  var d = [];
  var x = h.height - h.area[0] - h.area[2];
  h.width - h.area[1] - h.area[3];
  var f = s * e.widthRatio;
  t12.forEach(function(t13, e2) {
    if (t13 === null) {
      d.push(null);
    } else {
      var a2 = {};
      a2.color = t13.color;
      a2.x = l[e2];
      a2.x += s / 2;
      var i = t13.data;
      var r = x * (i * c - o) / (n - o);
      a2.y = h.height - r - h.area[2];
      a2.value = i;
      a2.width = f;
      d.push(a2);
    }
  });
  return d;
}
function getBarDataPoints(t12, o, n, l, e, s, a) {
  var h = arguments.length > 7 && arguments[7] !== void 0 ? arguments[7] : 1;
  var c = [];
  s.height - s.area[0] - s.area[2];
  var d = s.width - s.area[1] - s.area[3];
  t12.forEach(function(t13, e2) {
    if (t13 === null) {
      c.push(null);
    } else {
      var a2 = {};
      a2.color = t13.color;
      a2.y = l[e2];
      var i = t13;
      if (typeof t13 === "object" && t13 !== null) {
        i = t13.value;
      }
      var r = d * (i - o) / (n - o);
      r *= h;
      a2.height = r;
      a2.value = i;
      a2.x = r + s.area[3];
      c.push(a2);
    }
  });
  return c;
}
function getStackDataPoints(t12, s, h, c, g, d, e, x, y) {
  var f = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : 1;
  var p = [];
  var u = d.height - d.area[0] - d.area[2];
  t12.forEach(function(t13, e2) {
    if (t13 === null) {
      p.push(null);
    } else {
      var a = {};
      a.color = t13.color;
      a.x = c[e2] + Math.round(g / 2);
      if (x > 0) {
        var i = 0;
        for (let t14 = 0; t14 <= x; t14++) {
          i += y[t14].data[e2];
        }
        var r = i - t13;
        var o = u * (i - s) / (h - s);
        var n = u * (r - s) / (h - s);
      } else {
        var i = t13;
        if (typeof t13 === "object" && t13 !== null) {
          i = t13.value;
        }
        var o = u * (i - s) / (h - s);
        var n = 0;
      }
      var l = n;
      o *= f;
      l *= f;
      a.y = d.height - Math.round(o) - d.area[2];
      a.y0 = d.height - Math.round(l) - d.area[2];
      p.push(a);
    }
  });
  return p;
}
function getBarStackDataPoints(t12, s, h, c, e, d, a, x, g) {
  var f = arguments.length > 9 && arguments[9] !== void 0 ? arguments[9] : 1;
  var p = [];
  var u = d.width - d.area[1] - d.area[3];
  t12.forEach(function(t13, e2) {
    if (t13 === null) {
      p.push(null);
    } else {
      var a2 = {};
      a2.color = t13.color;
      a2.y = c[e2];
      if (x > 0) {
        var i = 0;
        for (let t14 = 0; t14 <= x; t14++) {
          i += g[t14].data[e2];
        }
        var r = i - t13;
        var o = u * (i - s) / (h - s);
        var n = u * (r - s) / (h - s);
      } else {
        var i = t13;
        if (typeof t13 === "object" && t13 !== null) {
          i = t13.value;
        }
        var o = u * (i - s) / (h - s);
        var n = 0;
      }
      var l = n;
      o *= f;
      l *= f;
      a2.height = o - l;
      a2.x = d.area[3] + o;
      a2.x0 = d.area[3] + l;
      p.push(a2);
    }
  });
  return p;
}
function getYAxisTextList(t12, e, h, c, a) {
  var i;
  if (c == "stack") {
    i = dataCombineStack(t12, e.categories.length);
  } else {
    i = dataCombine(t12);
  }
  var r = [];
  i = i.filter(function(t13) {
    if (typeof t13 === "object" && t13 !== null) {
      if (t13.constructor.toString().indexOf("Array") > -1) {
        return t13 !== null;
      } else {
        return t13.value !== null;
      }
    } else {
      return t13 !== null;
    }
  });
  i.map(function(t13) {
    if (typeof t13 === "object") {
      if (t13.constructor.toString().indexOf("Array") > -1) {
        if (e.type == "candle") {
          t13.map(function(t14) {
            r.push(t14);
          });
        } else {
          r.push(t13[1]);
        }
      } else {
        r.push(t13.value);
      }
    } else {
      r.push(t13);
    }
  });
  var o = a.min || 0;
  var n = a.max || 0;
  if (r.length > 0) {
    o = Math.min.apply(this, r);
    n = Math.max.apply(this, r);
  }
  if (o === n) {
    if (n == 0) {
      n = 10;
    } else {
      o = 0;
    }
  }
  var l = getDataRange(o, n);
  var x = a.min === void 0 || a.min === null ? l.minRange : a.min;
  var f = a.max === void 0 || a.max === null ? l.maxRange : a.max;
  var p = (f - x) / e.yAxis.splitNumber;
  var u = [];
  for (var s = 0; s <= e.yAxis.splitNumber; s++) {
    u.push(x + p * s);
  }
  return u.reverse();
}
function calYAxisData(a, o, e, n) {
  var l = assign({}, { type: "" }, o.extra.column);
  var t12 = o.yAxis.data.length;
  var s = new Array(t12);
  if (t12 > 0) {
    for (let e2 = 0; e2 < t12; e2++) {
      s[e2] = [];
      for (let t13 = 0; t13 < a.length; t13++) {
        if (a[t13].index == e2) {
          s[e2].push(a[t13]);
        }
      }
    }
    var h = new Array(t12);
    var c = new Array(t12);
    var d = new Array(t12);
    for (let r = 0; r < t12; r++) {
      let i2 = o.yAxis.data[r];
      if (o.yAxis.disabled == true) {
        i2.disabled = true;
      }
      if (i2.type === "categories") {
        if (!i2.formatter) {
          i2.formatter = (t14, e2, a3) => {
            return t14 + (i2.unit || "");
          };
        }
        i2.categories = i2.categories || o.categories;
        h[r] = i2.categories;
      } else {
        if (!i2.formatter) {
          i2.formatter = (t14, e2, a3) => {
            return util.toFixed(t14, i2.tofix || 0) + (i2.unit || "");
          };
        }
        h[r] = getYAxisTextList(s[r], o, e, l.type, i2);
      }
      let a2 = i2.fontSize * o.pix || e.fontSize;
      d[r] = { position: i2.position ? i2.position : "left", width: 0 };
      c[r] = h[r].map(function(t14, e2) {
        t14 = i2.formatter(t14, e2, o);
        d[r].width = Math.max(d[r].width, measureText(t14, a2, n) + 5);
        return t14;
      });
      let t13 = i2.calibration ? 4 * o.pix : 0;
      d[r].width += t13 + 3 * o.pix;
      if (i2.disabled === true) {
        d[r].width = 0;
      }
    }
  } else {
    var h = new Array(1);
    var c = new Array(1);
    var d = new Array(1);
    if (o.type === "bar") {
      h[0] = o.categories;
      if (!o.yAxis.formatter) {
        o.yAxis.formatter = (t13, e2, a2) => {
          return t13 + (a2.yAxis.unit || "");
        };
      }
    } else {
      if (!o.yAxis.formatter) {
        o.yAxis.formatter = (t13, e2, a2) => {
          return t13.toFixed(a2.yAxis.tofix) + (a2.yAxis.unit || "");
        };
      }
      h[0] = getYAxisTextList(a, o, e, l.type, {});
    }
    d[0] = { position: "left", width: 0 };
    var i = o.yAxis.fontSize * o.pix || e.fontSize;
    c[0] = h[0].map(function(t13, e2) {
      t13 = o.yAxis.formatter(t13, e2, o);
      d[0].width = Math.max(d[0].width, measureText(t13, i, n) + 5);
      return t13;
    });
    d[0].width += 3 * o.pix;
    if (o.yAxis.disabled === true) {
      d[0] = { position: "left", width: 0 };
      o.yAxis.data[0] = { disabled: true };
    } else {
      o.yAxis.data[0] = { disabled: false, position: "left", max: o.yAxis.max, min: o.yAxis.min, formatter: o.yAxis.formatter };
      if (o.type === "bar") {
        o.yAxis.data[0].categories = o.categories;
        o.yAxis.data[0].type = "categories";
      }
    }
  }
  return { rangesFormat: c, ranges: h, yAxisWidth: d };
}
function calTooltipYAxisData(r, t12, o, e, a) {
  let n = [].concat(o.chartData.yAxisData.ranges);
  let l = o.height - o.area[0] - o.area[2];
  let s = o.area[0];
  let h = [];
  for (let i = 0; i < n.length; i++) {
    let t13 = Math.max.apply(this, n[i]);
    let e2 = Math.min.apply(this, n[i]);
    let a2 = t13 - (t13 - e2) * (r - s) / l;
    a2 = o.yAxis.data && o.yAxis.data[i].formatter ? o.yAxis.data[i].formatter(a2, i, o) : a2.toFixed(0);
    h.push(String(a2));
  }
  return h;
}
function calMarkLineData(i, r) {
  let o, n;
  let l = r.height - r.area[0] - r.area[2];
  for (let a = 0; a < i.length; a++) {
    i[a].yAxisIndex = i[a].yAxisIndex ? i[a].yAxisIndex : 0;
    let t12 = [].concat(r.chartData.yAxisData.ranges[i[a].yAxisIndex]);
    o = t12.pop();
    n = t12.shift();
    let e = l * (i[a].value - o) / (n - o);
    i[a].y = r.height - Math.round(e) - r.area[2];
  }
  return i;
}
function contextRotate(t12, e) {
  if (e.rotateLock !== true) {
    t12.translate(e.height, 0);
    t12.rotate(90 * Math.PI / 180);
  } else if (e._rotate_ !== true) {
    t12.translate(e.height, 0);
    t12.rotate(90 * Math.PI / 180);
    e._rotate_ = true;
  }
}
function drawPointShape(t12, e, a, i, r) {
  i.beginPath();
  if (r.dataPointShapeType == "hollow") {
    i.setStrokeStyle(e);
    i.setFillStyle(r.background);
    i.setLineWidth(2 * r.pix);
  } else {
    i.setStrokeStyle("#ffffff");
    i.setFillStyle(e);
    i.setLineWidth(1 * r.pix);
  }
  if (a === "diamond") {
    t12.forEach(function(t13, e2) {
      if (t13 !== null) {
        i.moveTo(t13.x, t13.y - 4.5);
        i.lineTo(t13.x - 4.5, t13.y);
        i.lineTo(t13.x, t13.y + 4.5);
        i.lineTo(t13.x + 4.5, t13.y);
        i.lineTo(t13.x, t13.y - 4.5);
      }
    });
  } else if (a === "circle") {
    t12.forEach(function(t13, e2) {
      if (t13 !== null) {
        i.moveTo(t13.x + 2.5 * r.pix, t13.y);
        i.arc(t13.x, t13.y, 3 * r.pix, 0, 2 * Math.PI, false);
      }
    });
  } else if (a === "square") {
    t12.forEach(function(t13, e2) {
      if (t13 !== null) {
        i.moveTo(t13.x - 3.5, t13.y - 3.5);
        i.rect(t13.x - 3.5, t13.y - 3.5, 7, 7);
      }
    });
  } else if (a === "triangle") {
    t12.forEach(function(t13, e2) {
      if (t13 !== null) {
        i.moveTo(t13.x, t13.y - 4.5);
        i.lineTo(t13.x - 4.5, t13.y + 4.5);
        i.lineTo(t13.x + 4.5, t13.y + 4.5);
        i.lineTo(t13.x, t13.y - 4.5);
      }
    });
  } else if (a === "none") {
    return;
  }
  i.closePath();
  i.fill();
  i.stroke();
}
function drawActivePoint(t12, e, a, i, r, o, n) {
  if (!r.tooltip) {
    return;
  }
  if (r.tooltip.group.length > 0 && r.tooltip.group.includes(n) == false) {
    return;
  }
  var l = typeof r.tooltip.index === "number" ? r.tooltip.index : r.tooltip.index[r.tooltip.group.indexOf(n)];
  i.beginPath();
  if (o.activeType == "hollow") {
    i.setStrokeStyle(e);
    i.setFillStyle(r.background);
    i.setLineWidth(2 * r.pix);
  } else {
    i.setStrokeStyle("#ffffff");
    i.setFillStyle(e);
    i.setLineWidth(1 * r.pix);
  }
  if (a === "diamond") {
    t12.forEach(function(t13, e2) {
      if (t13 !== null && l == e2) {
        i.moveTo(t13.x, t13.y - 4.5);
        i.lineTo(t13.x - 4.5, t13.y);
        i.lineTo(t13.x, t13.y + 4.5);
        i.lineTo(t13.x + 4.5, t13.y);
        i.lineTo(t13.x, t13.y - 4.5);
      }
    });
  } else if (a === "circle") {
    t12.forEach(function(t13, e2) {
      if (t13 !== null && l == e2) {
        i.moveTo(t13.x + 2.5 * r.pix, t13.y);
        i.arc(t13.x, t13.y, 3 * r.pix, 0, 2 * Math.PI, false);
      }
    });
  } else if (a === "square") {
    t12.forEach(function(t13, e2) {
      if (t13 !== null && l == e2) {
        i.moveTo(t13.x - 3.5, t13.y - 3.5);
        i.rect(t13.x - 3.5, t13.y - 3.5, 7, 7);
      }
    });
  } else if (a === "triangle") {
    t12.forEach(function(t13, e2) {
      if (t13 !== null && l == e2) {
        i.moveTo(t13.x, t13.y - 4.5);
        i.lineTo(t13.x - 4.5, t13.y + 4.5);
        i.lineTo(t13.x + 4.5, t13.y + 4.5);
        i.lineTo(t13.x, t13.y - 4.5);
      }
    });
  } else if (a === "none") {
    return;
  }
  i.closePath();
  i.fill();
  i.stroke();
}
function drawRingTitle(t12, e, a, i) {
  var r = t12.title.fontSize || e.titleFontSize;
  var o = t12.subtitle.fontSize || e.subtitleFontSize;
  var n = t12.title.name || "";
  var l = t12.subtitle.name || "";
  var c = t12.title.color || t12.fontColor;
  var d = t12.subtitle.color || t12.fontColor;
  var x = n ? r : 0;
  var f = l ? o : 0;
  var s = 5;
  if (l) {
    var p = measureText(l, o * t12.pix, a);
    var u = i.x - p / 2 + (t12.subtitle.offsetX || 0) * t12.pix;
    var h = i.y + o * t12.pix / 2 + (t12.subtitle.offsetY || 0) * t12.pix;
    if (n) {
      h += (x * t12.pix + s) / 2;
    }
    a.beginPath();
    a.setFontSize(o * t12.pix);
    a.setFillStyle(d);
    a.fillText(l, u, h);
    a.closePath();
    a.stroke();
  }
  if (n) {
    var g = measureText(n, r * t12.pix, a);
    var y = i.x - g / 2 + (t12.title.offsetX || 0);
    var v = i.y + r * t12.pix / 2 + (t12.title.offsetY || 0) * t12.pix;
    if (l) {
      v -= (f * t12.pix + s) / 2;
    }
    a.beginPath();
    a.setFontSize(r * t12.pix);
    a.setFillStyle(c);
    a.fillText(n, y, v);
    a.closePath();
    a.stroke();
  }
}
function drawPointText(t12, o, n, l, s) {
  var h = o.data;
  var c = o.textOffset ? o.textOffset : 0;
  t12.forEach(function(t13, e) {
    if (t13 !== null) {
      l.beginPath();
      var a = o.textSize ? o.textSize * s.pix : n.fontSize;
      l.setFontSize(a);
      l.setFillStyle(o.textColor || s.fontColor);
      var i = h[e];
      if (typeof h[e] === "object" && h[e] !== null) {
        if (h[e].constructor.toString().indexOf("Array") > -1) {
          i = h[e][1];
        } else {
          i = h[e].value;
        }
      }
      var r = o.formatter ? o.formatter(i, e, o, s) : i;
      l.setTextAlign("center");
      l.fillText(String(r), t13.x, t13.y - 4 + c * s.pix);
      l.closePath();
      l.stroke();
      l.setTextAlign("left");
    }
  });
}
function drawColumePointText(t12, n, l, s, h) {
  var c = n.data;
  var d = n.textOffset ? n.textOffset : 0;
  var x = h.extra.column.labelPosition;
  t12.forEach(function(t13, e) {
    if (t13 !== null) {
      s.beginPath();
      var a = n.textSize ? n.textSize * h.pix : l.fontSize;
      s.setFontSize(a);
      s.setFillStyle(n.textColor || h.fontColor);
      var i = c[e];
      if (typeof c[e] === "object" && c[e] !== null) {
        if (c[e].constructor.toString().indexOf("Array") > -1) {
          i = c[e][1];
        } else {
          i = c[e].value;
        }
      }
      var r = n.formatter ? n.formatter(i, e, n, h) : i;
      s.setTextAlign("center");
      var o = t13.y - 4 * h.pix + d * h.pix;
      if (t13.y > n.zeroPoints) {
        o = t13.y + d * h.pix + a;
      }
      if (x == "insideTop") {
        o = t13.y + a + d * h.pix;
        if (t13.y > n.zeroPoints) {
          o = t13.y - d * h.pix - 4 * h.pix;
        }
      }
      if (x == "center") {
        o = t13.y + d * h.pix + (h.height - h.area[2] - t13.y + a) / 2;
        if (n.zeroPoints < h.height - h.area[2]) {
          o = t13.y + d * h.pix + (n.zeroPoints - t13.y + a) / 2;
        }
        if (t13.y > n.zeroPoints) {
          o = t13.y - d * h.pix - (t13.y - n.zeroPoints - a) / 2;
        }
        if (h.extra.column.type == "stack") {
          o = t13.y + d * h.pix + (t13.y0 - t13.y + a) / 2;
        }
      }
      if (x == "bottom") {
        o = h.height - h.area[2] + d * h.pix - 4 * h.pix;
        if (n.zeroPoints < h.height - h.area[2]) {
          o = n.zeroPoints + d * h.pix - 4 * h.pix;
        }
        if (t13.y > n.zeroPoints) {
          o = n.zeroPoints - d * h.pix + a + 2 * h.pix;
        }
        if (h.extra.column.type == "stack") {
          o = t13.y0 + d * h.pix - 4 * h.pix;
        }
      }
      s.fillText(String(r), t13.x, o);
      s.closePath();
      s.stroke();
      s.setTextAlign("left");
    }
  });
}
function drawMountPointText(t12, n, l, s, h, c) {
  n.data;
  var d = n.textOffset ? n.textOffset : 0;
  h.extra.mount.labelPosition;
  t12.forEach(function(t13, e) {
    if (t13 !== null) {
      s.beginPath();
      var a = n[e].textSize ? n[e].textSize * h.pix : l.fontSize;
      s.setFontSize(a);
      s.setFillStyle(n[e].textColor || h.fontColor);
      var i = t13.value;
      var r = n[e].formatter ? n[e].formatter(i, e, n, h) : i;
      s.setTextAlign("center");
      var o = t13.y - 4 * h.pix + d * h.pix;
      if (t13.y > c) {
        o = t13.y + d * h.pix + a;
      }
      s.fillText(String(r), t13.x, o);
      s.closePath();
      s.stroke();
      s.setTextAlign("left");
    }
  });
}
function drawBarPointText(t12, o, n, l, s) {
  var h = o.data;
  o.textOffset ? o.textOffset : 0;
  t12.forEach(function(t13, e) {
    if (t13 !== null) {
      l.beginPath();
      var a = o.textSize ? o.textSize * s.pix : n.fontSize;
      l.setFontSize(a);
      l.setFillStyle(o.textColor || s.fontColor);
      var i = h[e];
      if (typeof h[e] === "object" && h[e] !== null) {
        i = h[e].value;
      }
      var r = o.formatter ? o.formatter(i, e, o, s) : i;
      l.setTextAlign("left");
      l.fillText(String(r), t13.x + 4 * s.pix, t13.y + a / 2 - 3);
      l.closePath();
      l.stroke();
    }
  });
}
function drawGaugeLabel(e, a, i, r, o, n) {
  a -= e.width / 2 + e.labelOffset * r.pix;
  a = a < 10 ? 10 : a;
  let t12;
  if (e.endAngle < e.startAngle) {
    t12 = 2 + e.endAngle - e.startAngle;
  } else {
    t12 = e.startAngle - e.endAngle;
  }
  let c = t12 / e.splitLine.splitNumber;
  let d = e.endNumber - e.startNumber;
  let x = d / e.splitLine.splitNumber;
  let l = e.startAngle;
  let s = e.startNumber;
  for (let t13 = 0; t13 < e.splitLine.splitNumber + 1; t13++) {
    var h = { x: a * Math.cos(l * Math.PI), y: a * Math.sin(l * Math.PI) };
    var f = e.formatter ? e.formatter(s, t13, r) : s;
    h.x += i.x - measureText(f, o.fontSize, n) / 2;
    h.y += i.y;
    var p = h.x;
    var u = h.y;
    n.beginPath();
    n.setFontSize(o.fontSize);
    n.setFillStyle(e.labelColor || r.fontColor);
    n.fillText(f, p, u + o.fontSize / 2);
    n.closePath();
    n.stroke();
    l += c;
    if (l >= 2) {
      l = l % 2;
    }
    s += x;
  }
}
function drawRadarLabel(t12, s, h, c, d, x) {
  var f = c.extra.radar || {};
  t12.forEach(function(t13, e) {
    if (f.labelPointShow === true && c.categories[e] !== "") {
      var a = { x: s * Math.cos(t13), y: s * Math.sin(t13) };
      var i = convertCoordinateOrigin(a.x, a.y, h);
      x.setFillStyle(f.labelPointColor);
      x.beginPath();
      x.arc(i.x, i.y, f.labelPointRadius * c.pix, 0, 2 * Math.PI, false);
      x.closePath();
      x.fill();
    }
    if (f.labelShow === true) {
      var r = { x: (s + d.radarLabelTextMargin * c.pix) * Math.cos(t13), y: (s + d.radarLabelTextMargin * c.pix) * Math.sin(t13) };
      var o = convertCoordinateOrigin(r.x, r.y, h);
      var n = o.x;
      var l = o.y;
      if (util.approximatelyEqual(r.x, 0)) {
        n -= measureText(c.categories[e] || "", d.fontSize, x) / 2;
      } else if (r.x < 0) {
        n -= measureText(c.categories[e] || "", d.fontSize, x);
      }
      x.beginPath();
      x.setFontSize(d.fontSize);
      x.setFillStyle(f.labelColor || c.fontColor);
      x.fillText(c.categories[e] || "", n, l + d.fontSize / 2);
      x.closePath();
      x.stroke();
    }
  });
}
function drawPieText(n, d, x, f, t12, l) {
  var p = x.pieChartLinePadding;
  var u = [];
  var g = null;
  var y = n.map(function(t13, e) {
    var a = t13.formatter ? t13.formatter(t13, e, n, d) : util.toFixed(t13._proportion_.toFixed(4) * 100) + "%";
    a = t13.labelText ? t13.labelText : a;
    var i = 2 * Math.PI - (t13._start_ + 2 * Math.PI * t13._proportion_ / 2);
    if (t13._rose_proportion_) {
      i = 2 * Math.PI - (t13._start_ + 2 * Math.PI * t13._rose_proportion_ / 2);
    }
    var r = t13.color;
    var o = t13._radius_;
    return { arc: i, text: a, color: r, radius: o, textColor: t13.textColor, textSize: t13.textSize, labelShow: t13.labelShow };
  });
  for (let c = 0; c < y.length; c++) {
    let t13 = y[c];
    let e = Math.cos(t13.arc) * (t13.radius + p);
    let a = Math.sin(t13.arc) * (t13.radius + p);
    let i = Math.cos(t13.arc) * t13.radius;
    let r = Math.sin(t13.arc) * t13.radius;
    let o = e >= 0 ? e + x.pieChartTextPadding : e - x.pieChartTextPadding;
    let n2 = a;
    let l2 = measureText(t13.text, t13.textSize * d.pix || x.fontSize, f);
    let s = n2;
    if (g && util.isSameXCoordinateArea(g.start, { x: o })) {
      if (o > 0) {
        s = Math.min(n2, g.start.y);
      } else if (e < 0) {
        s = Math.max(n2, g.start.y);
      } else {
        if (n2 > 0) {
          s = Math.max(n2, g.start.y);
        } else {
          s = Math.min(n2, g.start.y);
        }
      }
    }
    if (o < 0) {
      o -= l2;
    }
    let h = { lineStart: { x: i, y: r }, lineEnd: { x: e, y: a }, start: { x: o, y: s }, width: l2, height: x.fontSize, text: t13.text, color: t13.color, textColor: t13.textColor, textSize: t13.textSize };
    g = avoidCollision(h, g);
    u.push(g);
  }
  for (let n2 = 0; n2 < u.length; n2++) {
    if (y[n2].labelShow === false) {
      continue;
    }
    let t13 = u[n2];
    let e = convertCoordinateOrigin(t13.lineStart.x, t13.lineStart.y, l);
    let a = convertCoordinateOrigin(t13.lineEnd.x, t13.lineEnd.y, l);
    let i = convertCoordinateOrigin(t13.start.x, t13.start.y, l);
    f.setLineWidth(1 * d.pix);
    f.setFontSize(t13.textSize * d.pix || x.fontSize);
    f.beginPath();
    f.setStrokeStyle(t13.color);
    f.setFillStyle(t13.color);
    f.moveTo(e.x, e.y);
    let r = t13.start.x < 0 ? i.x + t13.width : i.x;
    let o = t13.start.x < 0 ? i.x - 5 : i.x + 5;
    f.quadraticCurveTo(a.x, a.y, r, i.y);
    f.moveTo(e.x, e.y);
    f.stroke();
    f.closePath();
    f.beginPath();
    f.moveTo(i.x + t13.width, i.y);
    f.arc(r, i.y, 2 * d.pix, 0, 2 * Math.PI);
    f.closePath();
    f.fill();
    f.beginPath();
    f.setFontSize(t13.textSize * d.pix || x.fontSize);
    f.setFillStyle(t13.textColor || d.fontColor);
    f.fillText(t13.text, o, i.y + 3);
    f.closePath();
    f.stroke();
    f.closePath();
  }
}
function drawToolTipSplitLine(r, o, n, l) {
  var s = o.extra.tooltip || {};
  s.gridType = s.gridType == void 0 ? "solid" : s.gridType;
  s.dashLength = s.dashLength == void 0 ? 4 : s.dashLength;
  var t12 = o.area[0];
  var h = o.height - o.area[2];
  if (s.gridType == "dash") {
    l.setLineDash([s.dashLength, s.dashLength]);
  }
  l.setStrokeStyle(s.gridColor || "#cccccc");
  l.setLineWidth(1 * o.pix);
  l.beginPath();
  l.moveTo(r, t12);
  l.lineTo(r, h);
  l.stroke();
  l.setLineDash([]);
  if (s.xAxisLabel) {
    let t13 = o.categories[o.tooltip.index];
    l.setFontSize(n.fontSize);
    let e = measureText(t13, n.fontSize, l);
    let a = r - 0.5 * e;
    let i = h + 2 * o.pix;
    l.beginPath();
    l.setFillStyle(hexToRgb(s.labelBgColor || n.toolTipBackground, s.labelBgOpacity || n.toolTipOpacity));
    l.setStrokeStyle(s.labelBgColor || n.toolTipBackground);
    l.setLineWidth(1 * o.pix);
    l.rect(a - s.boxPadding * o.pix, i, e + 2 * s.boxPadding * o.pix, n.fontSize + 2 * s.boxPadding * o.pix);
    l.closePath();
    l.stroke();
    l.fill();
    l.beginPath();
    l.setFontSize(n.fontSize);
    l.setFillStyle(s.labelFontColor || o.fontColor);
    l.fillText(String(t13), a, i + s.boxPadding * o.pix + n.fontSize);
    l.closePath();
    l.stroke();
  }
}
function drawMarkLine(h, t12, c) {
  let e = assign({}, { type: "solid", dashLength: 4, data: [] }, h.extra.markLine);
  let a = h.area[3];
  let i = h.width - h.area[1];
  let r = calMarkLineData(e.data, h);
  for (let t13 = 0; t13 < r.length; t13++) {
    let s = assign({}, { lineColor: "#DE4A42", showLabel: false, labelFontSize: 13, labelPadding: 6, labelFontColor: "#666666", labelBgColor: "#DFE8FF", labelBgOpacity: 0.8, labelAlign: "left", labelOffsetX: 0, labelOffsetY: 0 }, r[t13]);
    if (e.type == "dash") {
      c.setLineDash([e.dashLength, e.dashLength]);
    }
    c.setStrokeStyle(s.lineColor);
    c.setLineWidth(1 * h.pix);
    c.beginPath();
    c.moveTo(a, s.y);
    c.lineTo(i, s.y);
    c.stroke();
    c.setLineDash([]);
    if (s.showLabel) {
      let t14 = s.labelFontSize * h.pix;
      let e2 = s.labelText ? s.labelText : s.value;
      c.setFontSize(t14);
      let a2 = measureText(e2, t14, c);
      let i2 = a2 + s.labelPadding * h.pix * 2;
      let r2 = s.labelAlign == "left" ? h.area[3] - i2 : h.width - h.area[1];
      r2 += s.labelOffsetX;
      let o = s.y - 0.5 * t14 - s.labelPadding * h.pix;
      o += s.labelOffsetY;
      let n = r2 + s.labelPadding * h.pix;
      s.y;
      c.setFillStyle(hexToRgb(s.labelBgColor, s.labelBgOpacity));
      c.setStrokeStyle(s.labelBgColor);
      c.setLineWidth(1 * h.pix);
      c.beginPath();
      c.rect(r2, o, i2, t14 + 2 * s.labelPadding * h.pix);
      c.closePath();
      c.stroke();
      c.fill();
      c.setFontSize(t14);
      c.setTextAlign("left");
      c.setFillStyle(s.labelFontColor);
      c.fillText(String(e2), n, o + t14 + s.labelPadding * h.pix / 2);
      c.stroke();
      c.setTextAlign("left");
    }
  }
}
function drawToolTipHorizentalLine(x, f, p, t12, e) {
  var u = assign({}, { gridType: "solid", dashLength: 4 }, x.extra.tooltip);
  var a = x.area[3];
  var i = x.width - x.area[1];
  if (u.gridType == "dash") {
    p.setLineDash([u.dashLength, u.dashLength]);
  }
  p.setStrokeStyle(u.gridColor || "#cccccc");
  p.setLineWidth(1 * x.pix);
  p.beginPath();
  p.moveTo(a, x.tooltip.offset.y);
  p.lineTo(i, x.tooltip.offset.y);
  p.stroke();
  p.setLineDash([]);
  if (u.yAxisLabel) {
    let l = u.boxPadding * x.pix;
    let s = calTooltipYAxisData(x.tooltip.offset.y, x.series, x);
    let h = x.chartData.yAxisData.yAxisWidth;
    let c = x.area[3];
    let d = x.width - x.area[1];
    for (let n = 0; n < s.length; n++) {
      p.setFontSize(u.fontSize * x.pix);
      let t13 = measureText(s[n], u.fontSize * x.pix, p);
      let e2, a2, i2;
      if (h[n].position == "left") {
        e2 = c - (t13 + l * 2) - 2 * x.pix;
        a2 = Math.max(e2, e2 + t13 + l * 2);
      } else {
        e2 = d + 2 * x.pix;
        a2 = Math.max(e2 + h[n].width, e2 + t13 + l * 2);
      }
      i2 = a2 - e2;
      let r = e2 + (i2 - t13) / 2;
      let o = x.tooltip.offset.y;
      p.beginPath();
      p.setFillStyle(hexToRgb(u.labelBgColor || f.toolTipBackground, u.labelBgOpacity || f.toolTipOpacity));
      p.setStrokeStyle(u.labelBgColor || f.toolTipBackground);
      p.setLineWidth(1 * x.pix);
      p.rect(e2, o - 0.5 * f.fontSize - l, i2, f.fontSize + 2 * l);
      p.closePath();
      p.stroke();
      p.fill();
      p.beginPath();
      p.setFontSize(f.fontSize);
      p.setFillStyle(u.labelFontColor || x.fontColor);
      p.fillText(s[n], r, o + 0.5 * f.fontSize);
      p.closePath();
      p.stroke();
      if (h[n].position == "left") {
        c -= h[n].width + x.yAxis.padding * x.pix;
      } else {
        d += h[n].width + x.yAxis.padding * x.pix;
      }
    }
  }
}
function drawToolTipSplitArea(t12, e, a, i, r) {
  var o = assign({}, { activeBgColor: "#000000", activeBgOpacity: 0.08, activeWidth: r }, e.extra.column);
  o.activeWidth = o.activeWidth > r ? r : o.activeWidth;
  var n = e.area[0];
  var l = e.height - e.area[2];
  i.beginPath();
  i.setFillStyle(hexToRgb(o.activeBgColor, o.activeBgOpacity));
  i.rect(t12 - o.activeWidth / 2, n, o.activeWidth, l - n);
  i.closePath();
  i.fill();
  i.setFillStyle("#FFFFFF");
}
function drawBarToolTipSplitArea(t12, e, a, i, r) {
  var o = assign({}, { activeBgColor: "#000000", activeBgOpacity: 0.08 }, e.extra.bar);
  var n = e.area[3];
  var l = e.width - e.area[1];
  i.beginPath();
  i.setFillStyle(hexToRgb(o.activeBgColor, o.activeBgOpacity));
  i.rect(n, t12 - r / 2, l - n, r);
  i.closePath();
  i.fill();
  i.setFillStyle("#FFFFFF");
}
function drawToolTip(e, r, o, a, n, i, f) {
  var l = assign({}, { showBox: true, showArrow: true, showCategory: false, bgColor: "#000000", bgOpacity: 0.7, borderColor: "#000000", borderWidth: 0, borderRadius: 0, borderOpacity: 0.7, boxPadding: 3, fontColor: "#FFFFFF", fontSize: 13, lineHeight: 20, legendShow: true, legendShape: "auto", splitLine: true }, o.extra.tooltip);
  if (l.showCategory == true && o.categories) {
    e.unshift({ text: o.categories[o.tooltip.index], color: null });
  }
  var s = l.fontSize * o.pix;
  var p = l.lineHeight * o.pix;
  var h = l.boxPadding * o.pix;
  var c = s;
  var u = 5 * o.pix;
  if (l.legendShow == false) {
    c = 0;
    u = 0;
  }
  var d = l.showArrow ? 8 * o.pix : 0;
  var g = false;
  if (o.type == "line" || o.type == "mount" || o.type == "area" || o.type == "candle" || o.type == "mix") {
    if (l.splitLine == true) {
      drawToolTipSplitLine(o.tooltip.offset.x, o, a, n);
    }
  }
  r = assign({ x: 0, y: 0 }, r);
  r.y -= 8 * o.pix;
  var y = e.map(function(t13) {
    return measureText(t13.text, s, n);
  });
  var x = c + u + 4 * h + Math.max.apply(null, y);
  var v = 2 * h + e.length * p;
  if (l.showBox == false) {
    return;
  }
  if (r.x - Math.abs(o._scrollDistance_ || 0) + d + x > o.width) {
    g = true;
  }
  if (v + r.y > o.height) {
    r.y = o.height - v;
  }
  n.beginPath();
  n.setFillStyle(hexToRgb(l.bgColor, l.bgOpacity));
  n.setLineWidth(l.borderWidth * o.pix);
  n.setStrokeStyle(hexToRgb(l.borderColor, l.borderOpacity));
  var t12 = l.borderRadius;
  if (g) {
    if (x + d > o.width) {
      r.x = o.width + Math.abs(o._scrollDistance_ || 0) + d + (x - o.width);
    }
    if (x > r.x) {
      r.x = o.width + Math.abs(o._scrollDistance_ || 0) + d + (x - o.width);
    }
    if (l.showArrow) {
      n.moveTo(r.x, r.y + 10 * o.pix);
      n.lineTo(r.x - d, r.y + 10 * o.pix + 5 * o.pix);
    }
    n.arc(r.x - d - t12, r.y + v - t12, t12, 0, Math.PI / 2, false);
    n.arc(r.x - d - Math.round(x) + t12, r.y + v - t12, t12, Math.PI / 2, Math.PI, false);
    n.arc(r.x - d - Math.round(x) + t12, r.y + t12, t12, -Math.PI, -Math.PI / 2, false);
    n.arc(r.x - d - t12, r.y + t12, t12, -Math.PI / 2, 0, false);
    if (l.showArrow) {
      n.lineTo(r.x - d, r.y + 10 * o.pix - 5 * o.pix);
      n.lineTo(r.x, r.y + 10 * o.pix);
    }
  } else {
    if (l.showArrow) {
      n.moveTo(r.x, r.y + 10 * o.pix);
      n.lineTo(r.x + d, r.y + 10 * o.pix - 5 * o.pix);
    }
    n.arc(r.x + d + t12, r.y + t12, t12, -Math.PI, -Math.PI / 2, false);
    n.arc(r.x + d + Math.round(x) - t12, r.y + t12, t12, -Math.PI / 2, 0, false);
    n.arc(r.x + d + Math.round(x) - t12, r.y + v - t12, t12, 0, Math.PI / 2, false);
    n.arc(r.x + d + t12, r.y + v - t12, t12, Math.PI / 2, Math.PI, false);
    if (l.showArrow) {
      n.lineTo(r.x + d, r.y + 10 * o.pix + 5 * o.pix);
      n.lineTo(r.x, r.y + 10 * o.pix);
    }
  }
  n.closePath();
  n.fill();
  if (l.borderWidth > 0) {
    n.stroke();
  }
  if (l.legendShow) {
    e.forEach(function(t13, e2) {
      if (t13.color !== null) {
        n.beginPath();
        n.setFillStyle(t13.color);
        var a2 = r.x + d + 2 * h;
        var i2 = r.y + (p - s) / 2 + p * e2 + h + 1;
        if (g) {
          a2 = r.x - x - d + 2 * h;
        }
        switch (t13.legendShape) {
          case "line":
            n.moveTo(a2, i2 + 0.5 * c - 2 * o.pix);
            n.fillRect(a2, i2 + 0.5 * c - 2 * o.pix, c, 4 * o.pix);
            break;
          case "triangle":
            n.moveTo(a2 + 7.5 * o.pix, i2 + 0.5 * c - 5 * o.pix);
            n.lineTo(a2 + 2.5 * o.pix, i2 + 0.5 * c + 5 * o.pix);
            n.lineTo(a2 + 12.5 * o.pix, i2 + 0.5 * c + 5 * o.pix);
            n.lineTo(a2 + 7.5 * o.pix, i2 + 0.5 * c - 5 * o.pix);
            break;
          case "diamond":
            n.moveTo(a2 + 7.5 * o.pix, i2 + 0.5 * c - 5 * o.pix);
            n.lineTo(a2 + 2.5 * o.pix, i2 + 0.5 * c);
            n.lineTo(a2 + 7.5 * o.pix, i2 + 0.5 * c + 5 * o.pix);
            n.lineTo(a2 + 12.5 * o.pix, i2 + 0.5 * c);
            n.lineTo(a2 + 7.5 * o.pix, i2 + 0.5 * c - 5 * o.pix);
            break;
          case "circle":
            n.moveTo(a2 + 7.5 * o.pix, i2 + 0.5 * c);
            n.arc(a2 + 7.5 * o.pix, i2 + 0.5 * c, 5 * o.pix, 0, 2 * Math.PI);
            break;
          case "rect":
            n.moveTo(a2, i2 + 0.5 * c - 5 * o.pix);
            n.fillRect(a2, i2 + 0.5 * c - 5 * o.pix, 15 * o.pix, 10 * o.pix);
            break;
          case "square":
            n.moveTo(a2 + 2 * o.pix, i2 + 0.5 * c - 5 * o.pix);
            n.fillRect(a2 + 2 * o.pix, i2 + 0.5 * c - 5 * o.pix, 10 * o.pix, 10 * o.pix);
            break;
          default:
            n.moveTo(a2, i2 + 0.5 * c - 5 * o.pix);
            n.fillRect(a2, i2 + 0.5 * c - 5 * o.pix, 15 * o.pix, 10 * o.pix);
        }
        n.closePath();
        n.fill();
      }
    });
  }
  e.forEach(function(t13, e2) {
    var a2 = r.x + d + 2 * h + c + u;
    if (g) {
      a2 = r.x - x - d + 2 * h + c + u;
    }
    var i2 = r.y + p * e2 + (p - s) / 2 - 1 + h + s;
    n.beginPath();
    n.setFontSize(s);
    n.setTextBaseline("normal");
    n.setFillStyle(l.fontColor);
    n.fillText(t13.text, a2, i2);
    n.closePath();
    n.stroke();
  });
}
function drawColumnDataPoints(T, b, S, w) {
  let A = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1;
  let t12 = b.chartData.xAxisData, P = t12.xAxisPoints, C = t12.eachSpacing;
  let D = assign({}, { type: "group", width: C / 2, meterBorder: 4, meterFillColor: "#FFFFFF", barBorderCircle: false, barBorderRadius: [], seriesGap: 2, linearType: "none", linearOpacity: 1, customColor: [], colorStop: 0, labelPosition: "outside" }, b.extra.column);
  let M = [];
  w.save();
  let L = -2;
  let F = P.length + 2;
  if (b._scrollDistance_ && b._scrollDistance_ !== 0 && b.enableScroll === true) {
    w.translate(b._scrollDistance_, 0);
    L = Math.floor(-b._scrollDistance_ / C) - 2;
    F = L + b.xAxis.itemCount + 4;
  }
  if (b.tooltip && b.tooltip.textList && b.tooltip.textList.length && A === 1) {
    drawToolTipSplitArea(b.tooltip.offset.x, b, S, w, C);
  }
  D.customColor = fillCustomColor(D.linearType, D.customColor, T, S);
  T.forEach(function(a, i) {
    let e, t13, o;
    e = [].concat(b.chartData.yAxisData.ranges[a.index]);
    t13 = e.pop();
    o = e.shift();
    let x = b.height - b.area[0] - b.area[2];
    let f = x * (0 - t13) / (o - t13);
    let n = b.height - Math.round(f) - b.area[2];
    a.zeroPoints = n;
    var p = a.data;
    switch (D.type) {
      case "group":
        var r = getColumnDataPoints(p, t13, o, P, C, b, S, n, A);
        var u = getStackDataPoints(p, t13, o, P, C, b, S, i, T, A);
        M.push(u);
        r = fixColumeData(r, C, T.length, i, S, b);
        for (let t14 = 0; t14 < r.length; t14++) {
          let o2 = r[t14];
          if (o2 !== null && t14 > L && t14 < F) {
            var l = o2.x - o2.width / 2;
            var s = b.height - o2.y - b.area[2];
            w.beginPath();
            var g = o2.color || a.color;
            var y = o2.color || a.color;
            if (D.linearType !== "none") {
              var v = w.createLinearGradient(l, o2.y, l, n);
              if (D.linearType == "opacity") {
                v.addColorStop(0, hexToRgb(g, D.linearOpacity));
                v.addColorStop(1, hexToRgb(g, 1));
              } else {
                v.addColorStop(0, hexToRgb(D.customColor[a.linearIndex], D.linearOpacity));
                v.addColorStop(D.colorStop, hexToRgb(D.customColor[a.linearIndex], D.linearOpacity));
                v.addColorStop(1, hexToRgb(g, 1));
              }
              g = v;
            }
            if (D.barBorderRadius && D.barBorderRadius.length === 4 || D.barBorderCircle === true) {
              const h = l;
              const c = o2.y > n ? n : o2.y;
              const d = o2.width;
              const s2 = Math.abs(n - o2.y);
              if (D.barBorderCircle) {
                D.barBorderRadius = [d / 2, d / 2, 0, 0];
              }
              if (o2.y > n) {
                D.barBorderRadius = [0, 0, d / 2, d / 2];
              }
              let [t15, e2, a2, i2] = D.barBorderRadius;
              let r2 = Math.min(d / 2, s2 / 2);
              t15 = t15 > r2 ? r2 : t15;
              e2 = e2 > r2 ? r2 : e2;
              a2 = a2 > r2 ? r2 : a2;
              i2 = i2 > r2 ? r2 : i2;
              t15 = t15 < 0 ? 0 : t15;
              e2 = e2 < 0 ? 0 : e2;
              a2 = a2 < 0 ? 0 : a2;
              i2 = i2 < 0 ? 0 : i2;
              w.arc(h + t15, c + t15, t15, -Math.PI, -Math.PI / 2);
              w.arc(h + d - e2, c + e2, e2, -Math.PI / 2, 0);
              w.arc(h + d - a2, c + s2 - a2, a2, 0, Math.PI / 2);
              w.arc(h + i2, c + s2 - i2, i2, Math.PI / 2, Math.PI);
            } else {
              w.moveTo(l, o2.y);
              w.lineTo(l + o2.width, o2.y);
              w.lineTo(l + o2.width, n);
              w.lineTo(l, n);
              w.lineTo(l, o2.y);
              w.setLineWidth(1);
              w.setStrokeStyle(y);
            }
            w.setFillStyle(g);
            w.closePath();
            w.fill();
          }
        }
        break;
      case "stack":
        var r = getStackDataPoints(p, t13, o, P, C, b, S, i, T, A);
        M.push(r);
        r = fixColumeStackData(r, C, T.length, i, S, b);
        for (let e2 = 0; e2 < r.length; e2++) {
          let t14 = r[e2];
          if (t14 !== null && e2 > L && e2 < F) {
            w.beginPath();
            var g = t14.color || a.color;
            var l = t14.x - t14.width / 2 + 1;
            var s = b.height - t14.y - b.area[2];
            var m = b.height - t14.y0 - b.area[2];
            if (i > 0) {
              s -= m;
            }
            w.setFillStyle(g);
            w.moveTo(l, t14.y);
            w.fillRect(l, t14.y, t14.width, s);
            w.closePath();
            w.fill();
          }
        }
        break;
      case "meter":
        var r = getDataPoints(p, t13, o, P, C, b, S, A);
        M.push(r);
        r = fixColumeMeterData(r, C, T.length, i, S, b, D.meterBorder);
        for (let t14 = 0; t14 < r.length; t14++) {
          let o2 = r[t14];
          if (o2 !== null && t14 > L && t14 < F) {
            w.beginPath();
            if (i == 0 && D.meterBorder > 0) {
              w.setStrokeStyle(a.color);
              w.setLineWidth(D.meterBorder * b.pix);
            }
            if (i == 0) {
              w.setFillStyle(D.meterFillColor);
            } else {
              w.setFillStyle(o2.color || a.color);
            }
            var l = o2.x - o2.width / 2;
            var s = b.height - o2.y - b.area[2];
            if (D.barBorderRadius && D.barBorderRadius.length === 4 || D.barBorderCircle === true) {
              const h = l;
              const c = o2.y;
              const d = o2.width;
              const s2 = n - o2.y;
              if (D.barBorderCircle) {
                D.barBorderRadius = [d / 2, d / 2, 0, 0];
              }
              let [t15, e2, a2, i2] = D.barBorderRadius;
              let r2 = Math.min(d / 2, s2 / 2);
              t15 = t15 > r2 ? r2 : t15;
              e2 = e2 > r2 ? r2 : e2;
              a2 = a2 > r2 ? r2 : a2;
              i2 = i2 > r2 ? r2 : i2;
              t15 = t15 < 0 ? 0 : t15;
              e2 = e2 < 0 ? 0 : e2;
              a2 = a2 < 0 ? 0 : a2;
              i2 = i2 < 0 ? 0 : i2;
              w.arc(h + t15, c + t15, t15, -Math.PI, -Math.PI / 2);
              w.arc(h + d - e2, c + e2, e2, -Math.PI / 2, 0);
              w.arc(h + d - a2, c + s2 - a2, a2, 0, Math.PI / 2);
              w.arc(h + i2, c + s2 - i2, i2, Math.PI / 2, Math.PI);
              w.fill();
            } else {
              w.moveTo(l, o2.y);
              w.lineTo(l + o2.width, o2.y);
              w.lineTo(l + o2.width, n);
              w.lineTo(l, n);
              w.lineTo(l, o2.y);
              w.fill();
            }
            if (i == 0 && D.meterBorder > 0) {
              w.closePath();
              w.stroke();
            }
          }
        }
        break;
    }
  });
  if (b.dataLabel !== false && A === 1) {
    T.forEach(function(t13, e) {
      let a, i, r;
      a = [].concat(b.chartData.yAxisData.ranges[t13.index]);
      i = a.pop();
      r = a.shift();
      var o = t13.data;
      switch (D.type) {
        case "group":
          var n = getColumnDataPoints(o, i, r, P, C, b, S, A);
          n = fixColumeData(n, C, T.length, e, S, b);
          drawColumePointText(n, t13, S, w, b);
          break;
        case "stack":
          var n = getStackDataPoints(o, i, r, P, C, b, S, e, T, A);
          drawColumePointText(n, t13, S, w, b);
          break;
        case "meter":
          var n = getDataPoints(o, i, r, P, C, b, S, A);
          drawColumePointText(n, t13, S, w, b);
          break;
      }
    });
  }
  w.restore();
  return { xAxisPoints: P, calPoints: M, eachSpacing: C };
}
function drawMountDataPoints(i, r, o, n) {
  let f = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1;
  let t12 = r.chartData.xAxisData, p = t12.xAxisPoints, l = t12.eachSpacing;
  let s = assign({}, { type: "mount", widthRatio: 1, borderWidth: 1, barBorderCircle: false, barBorderRadius: [], linearType: "none", linearOpacity: 1, customColor: [], colorStop: 0 }, r.extra.mount);
  s.widthRatio = s.widthRatio <= 0 ? 0 : s.widthRatio;
  s.widthRatio = s.widthRatio >= 2 ? 2 : s.widthRatio;
  n.save();
  let u = -2;
  let g = p.length + 2;
  if (r._scrollDistance_ && r._scrollDistance_ !== 0 && r.enableScroll === true) {
    n.translate(r._scrollDistance_, 0);
    u = Math.floor(-r._scrollDistance_ / l) - 2;
    g = u + r.xAxis.itemCount + 4;
  }
  s.customColor = fillCustomColor(s.linearType, s.customColor, i, o);
  let y, v, m;
  y = [].concat(r.chartData.yAxisData.ranges[0]);
  v = y.pop();
  m = y.shift();
  let T = r.height - r.area[0] - r.area[2];
  let b = T * (0 - v) / (m - v);
  let h = r.height - Math.round(b) - r.area[2];
  var c = getMountDataPoints(i, v, m, p, l, r, s, h, f);
  switch (s.type) {
    case "bar":
      for (let t13 = 0; t13 < c.length; t13++) {
        let o2 = c[t13];
        if (o2 !== null && t13 > u && t13 < g) {
          var d = o2.x - l * s.widthRatio / 2;
          var S = r.height - o2.y - r.area[2];
          n.beginPath();
          var a = o2.color || i[t13].color;
          var w = o2.color || i[t13].color;
          if (s.linearType !== "none") {
            var x = n.createLinearGradient(d, o2.y, d, h);
            if (s.linearType == "opacity") {
              x.addColorStop(0, hexToRgb(a, s.linearOpacity));
              x.addColorStop(1, hexToRgb(a, 1));
            } else {
              x.addColorStop(0, hexToRgb(s.customColor[i[t13].linearIndex], s.linearOpacity));
              x.addColorStop(s.colorStop, hexToRgb(s.customColor[i[t13].linearIndex], s.linearOpacity));
              x.addColorStop(1, hexToRgb(a, 1));
            }
            a = x;
          }
          if (s.barBorderRadius && s.barBorderRadius.length === 4 || s.barBorderCircle === true) {
            const A = d;
            const P = o2.y > h ? h : o2.y;
            const C = o2.width;
            const S2 = Math.abs(h - o2.y);
            if (s.barBorderCircle) {
              s.barBorderRadius = [C / 2, C / 2, 0, 0];
            }
            if (o2.y > h) {
              s.barBorderRadius = [0, 0, C / 2, C / 2];
            }
            let [t14, e, a2, i2] = s.barBorderRadius;
            let r2 = Math.min(C / 2, S2 / 2);
            t14 = t14 > r2 ? r2 : t14;
            e = e > r2 ? r2 : e;
            a2 = a2 > r2 ? r2 : a2;
            i2 = i2 > r2 ? r2 : i2;
            t14 = t14 < 0 ? 0 : t14;
            e = e < 0 ? 0 : e;
            a2 = a2 < 0 ? 0 : a2;
            i2 = i2 < 0 ? 0 : i2;
            n.arc(A + t14, P + t14, t14, -Math.PI, -Math.PI / 2);
            n.arc(A + C - e, P + e, e, -Math.PI / 2, 0);
            n.arc(A + C - a2, P + S2 - a2, a2, 0, Math.PI / 2);
            n.arc(A + i2, P + S2 - i2, i2, Math.PI / 2, Math.PI);
          } else {
            n.moveTo(d, o2.y);
            n.lineTo(d + o2.width, o2.y);
            n.lineTo(d + o2.width, h);
            n.lineTo(d, h);
            n.lineTo(d, o2.y);
          }
          n.setStrokeStyle(w);
          n.setFillStyle(a);
          if (s.borderWidth > 0) {
            n.setLineWidth(s.borderWidth * r.pix);
            n.closePath();
            n.stroke();
          }
          n.fill();
        }
      }
      break;
    case "triangle":
      for (let e = 0; e < c.length; e++) {
        let t13 = c[e];
        if (t13 !== null && e > u && e < g) {
          var d = t13.x - l * s.widthRatio / 2;
          var S = r.height - t13.y - r.area[2];
          n.beginPath();
          var a = t13.color || i[e].color;
          var w = t13.color || i[e].color;
          if (s.linearType !== "none") {
            var x = n.createLinearGradient(d, t13.y, d, h);
            if (s.linearType == "opacity") {
              x.addColorStop(0, hexToRgb(a, s.linearOpacity));
              x.addColorStop(1, hexToRgb(a, 1));
            } else {
              x.addColorStop(0, hexToRgb(s.customColor[i[e].linearIndex], s.linearOpacity));
              x.addColorStop(s.colorStop, hexToRgb(s.customColor[i[e].linearIndex], s.linearOpacity));
              x.addColorStop(1, hexToRgb(a, 1));
            }
            a = x;
          }
          n.moveTo(d, h);
          n.lineTo(t13.x, t13.y);
          n.lineTo(d + t13.width, h);
          n.setStrokeStyle(w);
          n.setFillStyle(a);
          if (s.borderWidth > 0) {
            n.setLineWidth(s.borderWidth * r.pix);
            n.stroke();
          }
          n.fill();
        }
      }
      break;
    case "mount":
      for (let e = 0; e < c.length; e++) {
        let t13 = c[e];
        if (t13 !== null && e > u && e < g) {
          var d = t13.x - l * s.widthRatio / 2;
          var S = r.height - t13.y - r.area[2];
          n.beginPath();
          var a = t13.color || i[e].color;
          var w = t13.color || i[e].color;
          if (s.linearType !== "none") {
            var x = n.createLinearGradient(d, t13.y, d, h);
            if (s.linearType == "opacity") {
              x.addColorStop(0, hexToRgb(a, s.linearOpacity));
              x.addColorStop(1, hexToRgb(a, 1));
            } else {
              x.addColorStop(0, hexToRgb(s.customColor[i[e].linearIndex], s.linearOpacity));
              x.addColorStop(s.colorStop, hexToRgb(s.customColor[i[e].linearIndex], s.linearOpacity));
              x.addColorStop(1, hexToRgb(a, 1));
            }
            a = x;
          }
          n.moveTo(d, h);
          n.bezierCurveTo(t13.x - t13.width / 4, h, t13.x - t13.width / 4, t13.y, t13.x, t13.y);
          n.bezierCurveTo(t13.x + t13.width / 4, t13.y, t13.x + t13.width / 4, h, d + t13.width, h);
          n.setStrokeStyle(w);
          n.setFillStyle(a);
          if (s.borderWidth > 0) {
            n.setLineWidth(s.borderWidth * r.pix);
            n.stroke();
          }
          n.fill();
        }
      }
      break;
    case "sharp":
      for (let e = 0; e < c.length; e++) {
        let t13 = c[e];
        if (t13 !== null && e > u && e < g) {
          var d = t13.x - l * s.widthRatio / 2;
          var S = r.height - t13.y - r.area[2];
          n.beginPath();
          var a = t13.color || i[e].color;
          var w = t13.color || i[e].color;
          if (s.linearType !== "none") {
            var x = n.createLinearGradient(d, t13.y, d, h);
            if (s.linearType == "opacity") {
              x.addColorStop(0, hexToRgb(a, s.linearOpacity));
              x.addColorStop(1, hexToRgb(a, 1));
            } else {
              x.addColorStop(0, hexToRgb(s.customColor[i[e].linearIndex], s.linearOpacity));
              x.addColorStop(s.colorStop, hexToRgb(s.customColor[i[e].linearIndex], s.linearOpacity));
              x.addColorStop(1, hexToRgb(a, 1));
            }
            a = x;
          }
          n.moveTo(d, h);
          n.quadraticCurveTo(t13.x - 0, h - S / 4, t13.x, t13.y);
          n.quadraticCurveTo(t13.x + 0, h - S / 4, d + t13.width, h);
          n.setStrokeStyle(w);
          n.setFillStyle(a);
          if (s.borderWidth > 0) {
            n.setLineWidth(s.borderWidth * r.pix);
            n.stroke();
          }
          n.fill();
        }
      }
      break;
  }
  if (r.dataLabel !== false && f === 1) {
    let t13, e, a2;
    t13 = [].concat(r.chartData.yAxisData.ranges[0]);
    e = t13.pop();
    a2 = t13.shift();
    var c = getMountDataPoints(i, e, a2, p, l, r, s, h, f);
    drawMountPointText(c, i, o, n, r, h);
  }
  n.restore();
  return { xAxisPoints: p, calPoints: c, eachSpacing: l };
}
function drawBarDataPoints(y, v, m, T) {
  let b = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1;
  let S = [];
  let w = (v.height - v.area[0] - v.area[2]) / v.categories.length;
  for (let t12 = 0; t12 < v.categories.length; t12++) {
    S.push(v.area[0] + w / 2 + w * t12);
  }
  let A = assign({}, { type: "group", width: w / 2, meterBorder: 4, meterFillColor: "#FFFFFF", barBorderCircle: false, barBorderRadius: [], seriesGap: 2, linearType: "none", linearOpacity: 1, customColor: [], colorStop: 0 }, v.extra.bar);
  let P = [];
  T.save();
  let C = -2;
  let D = S.length + 2;
  if (v.tooltip && v.tooltip.textList && v.tooltip.textList.length && b === 1) {
    drawBarToolTipSplitArea(v.tooltip.offset.y, v, m, T, w);
  }
  A.customColor = fillCustomColor(A.linearType, A.customColor, y, m);
  y.forEach(function(a, t12) {
    let o, e, d;
    o = [].concat(v.chartData.xAxisData.ranges);
    d = o.pop();
    e = o.shift();
    var x = a.data;
    switch (A.type) {
      case "group":
        var i = getBarDataPoints(x, e, d, S, w, v, m, b);
        var f = getBarStackDataPoints(x, e, d, S, w, v, m, t12, y, b);
        P.push(f);
        i = fixBarData(i, w, y.length, t12, m, v);
        for (let t13 = 0; t13 < i.length; t13++) {
          let o2 = i[t13];
          if (o2 !== null && t13 > C && t13 < D) {
            var n = v.area[3];
            var r = o2.y - o2.width / 2;
            o2.height;
            T.beginPath();
            var l = o2.color || a.color;
            var u = o2.color || a.color;
            if (A.linearType !== "none") {
              var s = T.createLinearGradient(n, o2.y, o2.x, o2.y);
              if (A.linearType == "opacity") {
                s.addColorStop(0, hexToRgb(l, A.linearOpacity));
                s.addColorStop(1, hexToRgb(l, 1));
              } else {
                s.addColorStop(0, hexToRgb(A.customColor[a.linearIndex], A.linearOpacity));
                s.addColorStop(A.colorStop, hexToRgb(A.customColor[a.linearIndex], A.linearOpacity));
                s.addColorStop(1, hexToRgb(l, 1));
              }
              l = s;
            }
            if (A.barBorderRadius && A.barBorderRadius.length === 4 || A.barBorderCircle === true) {
              const g = n;
              const h = o2.width;
              const c = o2.y - o2.width / 2;
              const p = o2.height;
              if (A.barBorderCircle) {
                A.barBorderRadius = [h / 2, h / 2, 0, 0];
              }
              let [t14, e2, a2, i2] = A.barBorderRadius;
              let r2 = Math.min(h / 2, p / 2);
              t14 = t14 > r2 ? r2 : t14;
              e2 = e2 > r2 ? r2 : e2;
              a2 = a2 > r2 ? r2 : a2;
              i2 = i2 > r2 ? r2 : i2;
              t14 = t14 < 0 ? 0 : t14;
              e2 = e2 < 0 ? 0 : e2;
              a2 = a2 < 0 ? 0 : a2;
              i2 = i2 < 0 ? 0 : i2;
              T.arc(g + i2, c + i2, i2, -Math.PI, -Math.PI / 2);
              T.arc(o2.x - t14, c + t14, t14, -Math.PI / 2, 0);
              T.arc(o2.x - e2, c + h - e2, e2, 0, Math.PI / 2);
              T.arc(g + a2, c + h - a2, a2, Math.PI / 2, Math.PI);
            } else {
              T.moveTo(n, r);
              T.lineTo(o2.x, r);
              T.lineTo(o2.x, r + o2.width);
              T.lineTo(n, r + o2.width);
              T.lineTo(n, r);
              T.setLineWidth(1);
              T.setStrokeStyle(u);
            }
            T.setFillStyle(l);
            T.closePath();
            T.fill();
          }
        }
        break;
      case "stack":
        var i = getBarStackDataPoints(x, e, d, S, w, v, m, t12, y, b);
        P.push(i);
        i = fixBarStackData(i, w, y.length, t12, m, v);
        for (let e2 = 0; e2 < i.length; e2++) {
          let t13 = i[e2];
          if (t13 !== null && e2 > C && e2 < D) {
            T.beginPath();
            var l = t13.color || a.color;
            var n = t13.x0;
            T.setFillStyle(l);
            T.moveTo(n, t13.y - t13.width / 2);
            T.fillRect(n, t13.y - t13.width / 2, t13.height, t13.width);
            T.closePath();
            T.fill();
          }
        }
        break;
    }
  });
  if (v.dataLabel !== false && b === 1) {
    y.forEach(function(t12, e) {
      let a, i, r;
      a = [].concat(v.chartData.xAxisData.ranges);
      r = a.pop();
      i = a.shift();
      var o = t12.data;
      switch (A.type) {
        case "group":
          var n = getBarDataPoints(o, i, r, S, w, v, m, b);
          n = fixBarData(n, w, y.length, e, m, v);
          drawBarPointText(n, t12, m, T, v);
          break;
        case "stack":
          var n = getBarStackDataPoints(o, i, r, S, w, v, m, e, y, b);
          drawBarPointText(n, t12, m, T, v);
          break;
      }
    });
  }
  return { yAxisPoints: S, calPoints: P, eachSpacing: w };
}
function drawCandleDataPoints(e, t12, h, c, d) {
  var g = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1;
  var s = assign({}, { color: {}, average: {} }, h.extra.candle);
  s.color = assign({}, { upLine: "#f04864", upFill: "#f04864", downLine: "#2fc25b", downFill: "#2fc25b" }, s.color);
  s.average = assign({}, { show: false, name: [], day: [], color: c.color }, s.average);
  h.extra.candle = s;
  let a = h.chartData.xAxisData, x = a.xAxisPoints, f = a.eachSpacing;
  let y = [];
  d.save();
  let p = -2;
  let v = x.length + 2;
  let u = 0;
  let m = h.width + f;
  if (h._scrollDistance_ && h._scrollDistance_ !== 0 && h.enableScroll === true) {
    d.translate(h._scrollDistance_, 0);
    p = Math.floor(-h._scrollDistance_ / f) - 2;
    v = p + h.xAxis.itemCount + 4;
    u = -h._scrollDistance_ - f * 2 + h.area[3];
    m = u + (h.xAxis.itemCount + 4) * f;
  }
  if (s.average.show || t12) {
    t12.forEach(function(e2, t13) {
      let a2, i, r;
      a2 = [].concat(h.chartData.yAxisData.ranges[e2.index]);
      i = a2.pop();
      r = a2.shift();
      var o = e2.data;
      var n = getDataPoints(o, i, r, x, f, h, c, g);
      var l = splitPoints(n, e2);
      for (let t14 = 0; t14 < l.length; t14++) {
        let i2 = l[t14];
        d.beginPath();
        d.setStrokeStyle(e2.color);
        d.setLineWidth(1);
        if (i2.length === 1) {
          d.moveTo(i2[0].x, i2[0].y);
          d.arc(i2[0].x, i2[0].y, 1, 0, 2 * Math.PI);
        } else {
          d.moveTo(i2[0].x, i2[0].y);
          let a3 = 0;
          for (let e3 = 0; e3 < i2.length; e3++) {
            let t15 = i2[e3];
            if (a3 == 0 && t15.x > u) {
              d.moveTo(t15.x, t15.y);
              a3 = 1;
            }
            if (e3 > 0 && t15.x > u && t15.x < m) {
              var s2 = createCurveControlPoints(i2, e3 - 1);
              d.bezierCurveTo(s2.ctrA.x, s2.ctrA.y, s2.ctrB.x, s2.ctrB.y, t15.x, t15.y);
            }
          }
          d.moveTo(i2[0].x, i2[0].y);
        }
        d.closePath();
        d.stroke();
      }
    });
  }
  e.forEach(function(t13, e2) {
    let a2, i, r;
    a2 = [].concat(h.chartData.yAxisData.ranges[t13.index]);
    i = a2.pop();
    r = a2.shift();
    var o = t13.data;
    var n = getCandleDataPoints(o, i, r, x, f, h, c, g);
    y.push(n);
    var l = splitPoints(n, t13);
    for (let e3 = 0; e3 < l[0].length; e3++) {
      if (e3 > p && e3 < v) {
        let t14 = l[0][e3];
        d.beginPath();
        if (o[e3][1] - o[e3][0] > 0) {
          d.setStrokeStyle(s.color.upLine);
          d.setFillStyle(s.color.upFill);
          d.setLineWidth(1 * h.pix);
          d.moveTo(t14[3].x, t14[3].y);
          d.lineTo(t14[1].x, t14[1].y);
          d.lineTo(t14[1].x - f / 4, t14[1].y);
          d.lineTo(t14[0].x - f / 4, t14[0].y);
          d.lineTo(t14[0].x, t14[0].y);
          d.lineTo(t14[2].x, t14[2].y);
          d.lineTo(t14[0].x, t14[0].y);
          d.lineTo(t14[0].x + f / 4, t14[0].y);
          d.lineTo(t14[1].x + f / 4, t14[1].y);
          d.lineTo(t14[1].x, t14[1].y);
          d.moveTo(t14[3].x, t14[3].y);
        } else {
          d.setStrokeStyle(s.color.downLine);
          d.setFillStyle(s.color.downFill);
          d.setLineWidth(1 * h.pix);
          d.moveTo(t14[3].x, t14[3].y);
          d.lineTo(t14[0].x, t14[0].y);
          d.lineTo(t14[0].x - f / 4, t14[0].y);
          d.lineTo(t14[1].x - f / 4, t14[1].y);
          d.lineTo(t14[1].x, t14[1].y);
          d.lineTo(t14[2].x, t14[2].y);
          d.lineTo(t14[1].x, t14[1].y);
          d.lineTo(t14[1].x + f / 4, t14[1].y);
          d.lineTo(t14[0].x + f / 4, t14[0].y);
          d.lineTo(t14[0].x, t14[0].y);
          d.moveTo(t14[3].x, t14[3].y);
        }
        d.closePath();
        d.fill();
        d.stroke();
      }
    }
  });
  d.restore();
  return { xAxisPoints: x, calPoints: y, eachSpacing: f };
}
function drawAreaDataPoints(t12, s, h, c) {
  var d = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1;
  var x = assign({}, { type: "straight", opacity: 0.2, addLine: false, width: 2, gradient: false, activeType: "none" }, s.extra.area);
  let e = s.chartData.xAxisData, f = e.xAxisPoints, p = e.eachSpacing;
  let y = s.height - s.area[2];
  let v = [];
  c.save();
  let u = 0;
  let g = s.width + p;
  if (s._scrollDistance_ && s._scrollDistance_ !== 0 && s.enableScroll === true) {
    c.translate(s._scrollDistance_, 0);
    u = -s._scrollDistance_ - p * 2 + s.area[3];
    g = u + (s.xAxis.itemCount + 4) * p;
  }
  t12.forEach(function(e2, t13) {
    let a, i, r;
    a = [].concat(s.chartData.yAxisData.ranges[e2.index]);
    i = a.pop();
    r = a.shift();
    let o = e2.data;
    let n = getDataPoints(o, i, r, f, p, s, h, d);
    v.push(n);
    let l = splitPoints(n, e2);
    for (let t14 = 0; t14 < l.length; t14++) {
      let r2 = l[t14];
      c.beginPath();
      c.setStrokeStyle(hexToRgb(e2.color, x.opacity));
      if (x.gradient) {
        let t15 = c.createLinearGradient(0, s.area[0], 0, s.height - s.area[2]);
        t15.addColorStop("0", hexToRgb(e2.color, x.opacity));
        t15.addColorStop("1.0", hexToRgb("#FFFFFF", 0.1));
        c.setFillStyle(t15);
      } else {
        c.setFillStyle(hexToRgb(e2.color, x.opacity));
      }
      c.setLineWidth(x.width * s.pix);
      if (r2.length > 1) {
        let t15 = r2[0];
        let e3 = r2[r2.length - 1];
        c.moveTo(t15.x, t15.y);
        let i2 = 0;
        if (x.type === "curve") {
          for (let a2 = 0; a2 < r2.length; a2++) {
            let e4 = r2[a2];
            if (i2 == 0 && e4.x > u) {
              c.moveTo(e4.x, e4.y);
              i2 = 1;
            }
            if (a2 > 0 && e4.x > u && e4.x < g) {
              let t16 = createCurveControlPoints(r2, a2 - 1);
              c.bezierCurveTo(t16.ctrA.x, t16.ctrA.y, t16.ctrB.x, t16.ctrB.y, e4.x, e4.y);
            }
          }
        }
        if (x.type === "straight") {
          for (let e4 = 0; e4 < r2.length; e4++) {
            let t16 = r2[e4];
            if (i2 == 0 && t16.x > u) {
              c.moveTo(t16.x, t16.y);
              i2 = 1;
            }
            if (e4 > 0 && t16.x > u && t16.x < g) {
              c.lineTo(t16.x, t16.y);
            }
          }
        }
        if (x.type === "step") {
          for (let e4 = 0; e4 < r2.length; e4++) {
            let t16 = r2[e4];
            if (i2 == 0 && t16.x > u) {
              c.moveTo(t16.x, t16.y);
              i2 = 1;
            }
            if (e4 > 0 && t16.x > u && t16.x < g) {
              c.lineTo(t16.x, r2[e4 - 1].y);
              c.lineTo(t16.x, t16.y);
            }
          }
        }
        c.lineTo(e3.x, y);
        c.lineTo(t15.x, y);
        c.lineTo(t15.x, t15.y);
      } else {
        let t15 = r2[0];
        c.moveTo(t15.x - p / 2, t15.y);
      }
      c.closePath();
      c.fill();
      if (x.addLine) {
        if (e2.lineType == "dash") {
          let t15 = e2.dashLength ? e2.dashLength : 8;
          t15 *= s.pix;
          c.setLineDash([t15, t15]);
        }
        c.beginPath();
        c.setStrokeStyle(e2.color);
        c.setLineWidth(x.width * s.pix);
        if (r2.length === 1) {
          c.moveTo(r2[0].x, r2[0].y);
        } else {
          c.moveTo(r2[0].x, r2[0].y);
          let i2 = 0;
          if (x.type === "curve") {
            for (let a2 = 0; a2 < r2.length; a2++) {
              let e3 = r2[a2];
              if (i2 == 0 && e3.x > u) {
                c.moveTo(e3.x, e3.y);
                i2 = 1;
              }
              if (a2 > 0 && e3.x > u && e3.x < g) {
                let t15 = createCurveControlPoints(r2, a2 - 1);
                c.bezierCurveTo(t15.ctrA.x, t15.ctrA.y, t15.ctrB.x, t15.ctrB.y, e3.x, e3.y);
              }
            }
          }
          if (x.type === "straight") {
            for (let e3 = 0; e3 < r2.length; e3++) {
              let t15 = r2[e3];
              if (i2 == 0 && t15.x > u) {
                c.moveTo(t15.x, t15.y);
                i2 = 1;
              }
              if (e3 > 0 && t15.x > u && t15.x < g) {
                c.lineTo(t15.x, t15.y);
              }
            }
          }
          if (x.type === "step") {
            for (let e3 = 0; e3 < r2.length; e3++) {
              let t15 = r2[e3];
              if (i2 == 0 && t15.x > u) {
                c.moveTo(t15.x, t15.y);
                i2 = 1;
              }
              if (e3 > 0 && t15.x > u && t15.x < g) {
                c.lineTo(t15.x, r2[e3 - 1].y);
                c.lineTo(t15.x, t15.y);
              }
            }
          }
          c.moveTo(r2[0].x, r2[0].y);
        }
        c.stroke();
        c.setLineDash([]);
      }
    }
    if (s.dataPointShape !== false) {
      drawPointShape(n, e2.color, e2.pointShape, c, s);
    }
    drawActivePoint(n, e2.color, e2.pointShape, c, s, x, t13);
  });
  if (s.dataLabel !== false && d === 1) {
    t12.forEach(function(t13, e2) {
      let a, i, r;
      a = [].concat(s.chartData.yAxisData.ranges[t13.index]);
      i = a.pop();
      r = a.shift();
      var o = t13.data;
      var n = getDataPoints(o, i, r, f, p, s, h, d);
      drawPointText(n, t13, h, c, s);
    });
  }
  c.restore();
  return { xAxisPoints: f, calPoints: v, eachSpacing: p };
}
function drawScatterDataPoints(t12, s, h, c) {
  var d = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1;
  assign({}, { type: "circle" }, s.extra.scatter);
  let e = s.chartData.xAxisData, x = e.xAxisPoints, f = e.eachSpacing;
  var r = [];
  c.save();
  let a = 0;
  s.width + f;
  if (s._scrollDistance_ && s._scrollDistance_ !== 0 && s.enableScroll === true) {
    c.translate(s._scrollDistance_, 0);
    a = -s._scrollDistance_ - f * 2 + s.area[3];
    a + (s.xAxis.itemCount + 4) * f;
  }
  t12.forEach(function(t13, e2) {
    let a2, i, r2;
    a2 = [].concat(s.chartData.yAxisData.ranges[t13.index]);
    i = a2.pop();
    r2 = a2.shift();
    var o = t13.data;
    var n = getDataPoints(o, i, r2, x, f, s, h, d);
    c.beginPath();
    c.setStrokeStyle(t13.color);
    c.setFillStyle(t13.color);
    c.setLineWidth(1 * s.pix);
    var l = t13.pointShape;
    if (l === "diamond") {
      n.forEach(function(t14, e3) {
        if (t14 !== null) {
          c.moveTo(t14.x, t14.y - 4.5);
          c.lineTo(t14.x - 4.5, t14.y);
          c.lineTo(t14.x, t14.y + 4.5);
          c.lineTo(t14.x + 4.5, t14.y);
          c.lineTo(t14.x, t14.y - 4.5);
        }
      });
    } else if (l === "circle") {
      n.forEach(function(t14, e3) {
        if (t14 !== null) {
          c.moveTo(t14.x + 2.5 * s.pix, t14.y);
          c.arc(t14.x, t14.y, 3 * s.pix, 0, 2 * Math.PI, false);
        }
      });
    } else if (l === "square") {
      n.forEach(function(t14, e3) {
        if (t14 !== null) {
          c.moveTo(t14.x - 3.5, t14.y - 3.5);
          c.rect(t14.x - 3.5, t14.y - 3.5, 7, 7);
        }
      });
    } else if (l === "triangle") {
      n.forEach(function(t14, e3) {
        if (t14 !== null) {
          c.moveTo(t14.x, t14.y - 4.5);
          c.lineTo(t14.x - 4.5, t14.y + 4.5);
          c.lineTo(t14.x + 4.5, t14.y + 4.5);
          c.lineTo(t14.x, t14.y - 4.5);
        }
      });
    } else if (l === "triangle") {
      return;
    }
    c.closePath();
    c.fill();
    c.stroke();
  });
  if (s.dataLabel !== false && d === 1) {
    t12.forEach(function(t13, e2) {
      let a2, i, r2;
      a2 = [].concat(s.chartData.yAxisData.ranges[t13.index]);
      i = a2.pop();
      r2 = a2.shift();
      var o = t13.data;
      var n = getDataPoints(o, i, r2, x, f, s, h, d);
      drawPointText(n, t13, h, c, s);
    });
  }
  c.restore();
  return { xAxisPoints: x, calPoints: r, eachSpacing: f };
}
function drawBubbleDataPoints(a, l, s, h) {
  var c = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1;
  var d = assign({}, { opacity: 1, border: 2 }, l.extra.bubble);
  let t12 = l.chartData.xAxisData, x = t12.xAxisPoints, f = t12.eachSpacing;
  var i = [];
  h.save();
  let e = 0;
  l.width + f;
  if (l._scrollDistance_ && l._scrollDistance_ !== 0 && l.enableScroll === true) {
    h.translate(l._scrollDistance_, 0);
    e = -l._scrollDistance_ - f * 2 + l.area[3];
    e + (l.xAxis.itemCount + 4) * f;
  }
  a.forEach(function(i2, t13) {
    let e2, a2, r;
    e2 = [].concat(l.chartData.yAxisData.ranges[i2.index]);
    a2 = e2.pop();
    r = e2.shift();
    var o = i2.data;
    var n = getDataPoints(o, a2, r, x, f, l, s, c);
    h.beginPath();
    h.setStrokeStyle(i2.color);
    h.setLineWidth(d.border * l.pix);
    h.setFillStyle(hexToRgb(i2.color, d.opacity));
    n.forEach(function(t14, e3) {
      h.moveTo(t14.x + t14.r, t14.y);
      h.arc(t14.x, t14.y, t14.r * l.pix, 0, 2 * Math.PI, false);
    });
    h.closePath();
    h.fill();
    h.stroke();
    if (l.dataLabel !== false && c === 1) {
      n.forEach(function(t14, e3) {
        h.beginPath();
        var a3 = i2.textSize * l.pix || s.fontSize;
        h.setFontSize(a3);
        h.setFillStyle(i2.textColor || "#FFFFFF");
        h.setTextAlign("center");
        h.fillText(String(t14.t), t14.x, t14.y + a3 / 2);
        h.closePath();
        h.stroke();
        h.setTextAlign("left");
      });
    }
  });
  h.restore();
  return { xAxisPoints: x, calPoints: i, eachSpacing: f };
}
function drawLineDataPoints(t12, d, x, f) {
  var p = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1;
  var u = assign({}, { type: "straight", width: 2, activeType: "none", linearType: "none", onShadow: false, animation: "vertical" }, d.extra.line);
  u.width *= d.pix;
  let e = d.chartData.xAxisData, g = e.xAxisPoints, y = e.eachSpacing;
  var T = [];
  f.save();
  let v = 0;
  let m = d.width + y;
  if (d._scrollDistance_ && d._scrollDistance_ !== 0 && d.enableScroll === true) {
    f.translate(d._scrollDistance_, 0);
    v = -d._scrollDistance_ - y * 2 + d.area[3];
    m = v + (d.xAxis.itemCount + 4) * y;
  }
  t12.forEach(function(e2, c) {
    f.beginPath();
    f.setStrokeStyle(e2.color);
    f.moveTo(-1e4, -1e4);
    f.lineTo(-10001, -10001);
    f.stroke();
    let t13, a, i;
    t13 = [].concat(d.chartData.yAxisData.ranges[e2.index]);
    a = t13.pop();
    i = t13.shift();
    var r = e2.data;
    var o = getLineDataPoints(r, a, i, g, y, d, x, u, p);
    T.push(o);
    var n = splitPoints(o, e2);
    if (e2.lineType == "dash") {
      let t14 = e2.dashLength ? e2.dashLength : 8;
      t14 *= d.pix;
      f.setLineDash([t14, t14]);
    }
    f.beginPath();
    var l = e2.color;
    if (u.linearType !== "none" && e2.linearColor && e2.linearColor.length > 0) {
      var s = f.createLinearGradient(d.chartData.xAxisData.startX, d.height / 2, d.chartData.xAxisData.endX, d.height / 2);
      for (var h = 0; h < e2.linearColor.length; h++) {
        s.addColorStop(e2.linearColor[h][0], hexToRgb(e2.linearColor[h][1], 1));
      }
      l = s;
    }
    f.setStrokeStyle(l);
    if (u.onShadow == true && e2.setShadow && e2.setShadow.length > 0) {
      f.setShadow(e2.setShadow[0], e2.setShadow[1], e2.setShadow[2], e2.setShadow[3]);
    } else {
      f.setShadow(0, 0, 0, "rgba(0,0,0,0)");
    }
    f.setLineWidth(u.width);
    n.forEach(function(i2, t14) {
      if (i2.length === 1) {
        f.moveTo(i2[0].x, i2[0].y);
      } else {
        f.moveTo(i2[0].x, i2[0].y);
        let a2 = 0;
        if (u.type === "curve") {
          for (let e3 = 0; e3 < i2.length; e3++) {
            let t15 = i2[e3];
            if (a2 == 0 && t15.x > v) {
              f.moveTo(t15.x, t15.y);
              a2 = 1;
            }
            if (e3 > 0 && t15.x > v && t15.x < m) {
              var r2 = createCurveControlPoints(i2, e3 - 1);
              f.bezierCurveTo(r2.ctrA.x, r2.ctrA.y, r2.ctrB.x, r2.ctrB.y, t15.x, t15.y);
            }
          }
        }
        if (u.type === "straight") {
          for (let e3 = 0; e3 < i2.length; e3++) {
            let t15 = i2[e3];
            if (a2 == 0 && t15.x > v) {
              f.moveTo(t15.x, t15.y);
              a2 = 1;
            }
            if (e3 > 0 && t15.x > v && t15.x < m) {
              f.lineTo(t15.x, t15.y);
            }
          }
        }
        if (u.type === "step") {
          for (let e3 = 0; e3 < i2.length; e3++) {
            let t15 = i2[e3];
            if (a2 == 0 && t15.x > v) {
              f.moveTo(t15.x, t15.y);
              a2 = 1;
            }
            if (e3 > 0 && t15.x > v && t15.x < m) {
              f.lineTo(t15.x, i2[e3 - 1].y);
              f.lineTo(t15.x, t15.y);
            }
          }
        }
        f.moveTo(i2[0].x, i2[0].y);
      }
    });
    f.stroke();
    f.setLineDash([]);
    if (d.dataPointShape !== false) {
      drawPointShape(o, e2.color, e2.pointShape, f, d);
    }
    drawActivePoint(o, e2.color, e2.pointShape, f, d, u);
  });
  if (d.dataLabel !== false && p === 1) {
    t12.forEach(function(t13, e2) {
      let a, i, r;
      a = [].concat(d.chartData.yAxisData.ranges[t13.index]);
      i = a.pop();
      r = a.shift();
      var o = t13.data;
      var n = getDataPoints(o, i, r, g, y, d, x, p);
      drawPointText(n, t13, x, f, d);
    });
  }
  f.restore();
  return { xAxisPoints: g, calPoints: T, eachSpacing: y };
}
function drawMixDataPoints(t12, v, m, T) {
  let D = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1;
  let e = v.chartData.xAxisData, b = e.xAxisPoints, S = e.eachSpacing;
  let w = assign({}, { width: S / 2, barBorderCircle: false, barBorderRadius: [], seriesGap: 2, linearType: "none", linearOpacity: 1, customColor: [], colorStop: 0 }, v.extra.mix.column);
  let A = assign({}, { opacity: 0.2, gradient: false }, v.extra.mix.area);
  let M = assign({}, { width: 2 }, v.extra.mix.line);
  let L = v.height - v.area[2];
  let F = [];
  var _ = 0;
  var k = 0;
  t12.forEach(function(t13, e2) {
    if (t13.type == "column") {
      k += 1;
    }
  });
  T.save();
  let R = -2;
  let I = b.length + 2;
  let P = 0;
  let C = v.width + S;
  if (v._scrollDistance_ && v._scrollDistance_ !== 0 && v.enableScroll === true) {
    T.translate(v._scrollDistance_, 0);
    R = Math.floor(-v._scrollDistance_ / S) - 2;
    I = R + v.xAxis.itemCount + 4;
    P = -v._scrollDistance_ - S * 2 + v.area[3];
    C = P + (v.xAxis.itemCount + 4) * S;
  }
  w.customColor = fillCustomColor(w.linearType, w.customColor, t12, m);
  t12.forEach(function(n, t13) {
    let o, x, f;
    o = [].concat(v.chartData.yAxisData.ranges[n.index]);
    x = o.pop();
    f = o.shift();
    var p = n.data;
    var a = getDataPoints(p, x, f, b, S, v, m, D);
    F.push(a);
    if (n.type == "column") {
      a = fixColumeData(a, S, k, _, m, v);
      for (let t14 = 0; t14 < a.length; t14++) {
        let o2 = a[t14];
        if (o2 !== null && t14 > R && t14 < I) {
          var l = o2.x - o2.width / 2;
          v.height - o2.y - v.area[2];
          T.beginPath();
          var e2 = o2.color || n.color;
          var u = o2.color || n.color;
          if (w.linearType !== "none") {
            var i = T.createLinearGradient(l, o2.y, l, v.height - v.area[2]);
            if (w.linearType == "opacity") {
              i.addColorStop(0, hexToRgb(e2, w.linearOpacity));
              i.addColorStop(1, hexToRgb(e2, 1));
            } else {
              i.addColorStop(0, hexToRgb(w.customColor[n.linearIndex], w.linearOpacity));
              i.addColorStop(w.colorStop, hexToRgb(w.customColor[n.linearIndex], w.linearOpacity));
              i.addColorStop(1, hexToRgb(e2, 1));
            }
            e2 = i;
          }
          if (w.barBorderRadius && w.barBorderRadius.length === 4 || w.barBorderCircle) {
            const h = l;
            const c = o2.y;
            const d = o2.width;
            const s = v.height - v.area[2] - o2.y;
            if (w.barBorderCircle) {
              w.barBorderRadius = [d / 2, d / 2, 0, 0];
            }
            let [t15, e3, a2, i2] = w.barBorderRadius;
            let r2 = Math.min(d / 2, s / 2);
            t15 = t15 > r2 ? r2 : t15;
            e3 = e3 > r2 ? r2 : e3;
            a2 = a2 > r2 ? r2 : a2;
            i2 = i2 > r2 ? r2 : i2;
            t15 = t15 < 0 ? 0 : t15;
            e3 = e3 < 0 ? 0 : e3;
            a2 = a2 < 0 ? 0 : a2;
            i2 = i2 < 0 ? 0 : i2;
            T.arc(h + t15, c + t15, t15, -Math.PI, -Math.PI / 2);
            T.arc(h + d - e3, c + e3, e3, -Math.PI / 2, 0);
            T.arc(h + d - a2, c + s - a2, a2, 0, Math.PI / 2);
            T.arc(h + i2, c + s - i2, i2, Math.PI / 2, Math.PI);
          } else {
            T.moveTo(l, o2.y);
            T.lineTo(l + o2.width, o2.y);
            T.lineTo(l + o2.width, v.height - v.area[2]);
            T.lineTo(l, v.height - v.area[2]);
            T.lineTo(l, o2.y);
            T.setLineWidth(1);
            T.setStrokeStyle(u);
          }
          T.setFillStyle(e2);
          T.closePath();
          T.fill();
        }
      }
      _ += 1;
    }
    if (n.type == "area") {
      let e3 = splitPoints(a, n);
      for (let t14 = 0; t14 < e3.length; t14++) {
        let i2 = e3[t14];
        T.beginPath();
        T.setStrokeStyle(n.color);
        T.setStrokeStyle(hexToRgb(n.color, A.opacity));
        if (A.gradient) {
          let t15 = T.createLinearGradient(0, v.area[0], 0, v.height - v.area[2]);
          t15.addColorStop("0", hexToRgb(n.color, A.opacity));
          t15.addColorStop("1.0", hexToRgb("#FFFFFF", 0.1));
          T.setFillStyle(t15);
        } else {
          T.setFillStyle(hexToRgb(n.color, A.opacity));
        }
        T.setLineWidth(2 * v.pix);
        if (i2.length > 1) {
          var r = i2[0];
          let t15 = i2[i2.length - 1];
          T.moveTo(r.x, r.y);
          let a2 = 0;
          if (n.style === "curve") {
            for (let e4 = 0; e4 < i2.length; e4++) {
              let t16 = i2[e4];
              if (a2 == 0 && t16.x > P) {
                T.moveTo(t16.x, t16.y);
                a2 = 1;
              }
              if (e4 > 0 && t16.x > P && t16.x < C) {
                var g = createCurveControlPoints(i2, e4 - 1);
                T.bezierCurveTo(g.ctrA.x, g.ctrA.y, g.ctrB.x, g.ctrB.y, t16.x, t16.y);
              }
            }
          } else {
            for (let e4 = 0; e4 < i2.length; e4++) {
              let t16 = i2[e4];
              if (a2 == 0 && t16.x > P) {
                T.moveTo(t16.x, t16.y);
                a2 = 1;
              }
              if (e4 > 0 && t16.x > P && t16.x < C) {
                T.lineTo(t16.x, t16.y);
              }
            }
          }
          T.lineTo(t15.x, L);
          T.lineTo(r.x, L);
          T.lineTo(r.x, r.y);
        } else {
          let t15 = i2[0];
          T.moveTo(t15.x - S / 2, t15.y);
        }
        T.closePath();
        T.fill();
      }
    }
    if (n.type == "line") {
      var y = splitPoints(a, n);
      y.forEach(function(i2, t14) {
        if (n.lineType == "dash") {
          let t15 = n.dashLength ? n.dashLength : 8;
          t15 *= v.pix;
          T.setLineDash([t15, t15]);
        }
        T.beginPath();
        T.setStrokeStyle(n.color);
        T.setLineWidth(M.width * v.pix);
        if (i2.length === 1) {
          T.moveTo(i2[0].x, i2[0].y);
        } else {
          T.moveTo(i2[0].x, i2[0].y);
          let a2 = 0;
          if (n.style == "curve") {
            for (let e3 = 0; e3 < i2.length; e3++) {
              let t15 = i2[e3];
              if (a2 == 0 && t15.x > P) {
                T.moveTo(t15.x, t15.y);
                a2 = 1;
              }
              if (e3 > 0 && t15.x > P && t15.x < C) {
                var r2 = createCurveControlPoints(i2, e3 - 1);
                T.bezierCurveTo(r2.ctrA.x, r2.ctrA.y, r2.ctrB.x, r2.ctrB.y, t15.x, t15.y);
              }
            }
          } else {
            for (let e3 = 0; e3 < i2.length; e3++) {
              let t15 = i2[e3];
              if (a2 == 0 && t15.x > P) {
                T.moveTo(t15.x, t15.y);
                a2 = 1;
              }
              if (e3 > 0 && t15.x > P && t15.x < C) {
                T.lineTo(t15.x, t15.y);
              }
            }
          }
          T.moveTo(i2[0].x, i2[0].y);
        }
        T.stroke();
        T.setLineDash([]);
      });
    }
    if (n.type == "point") {
      n.addPoint = true;
    }
    if (n.addPoint == true && n.type !== "column") {
      drawPointShape(a, n.color, n.pointShape, T, v);
    }
  });
  if (v.dataLabel !== false && D === 1) {
    var _ = 0;
    t12.forEach(function(t13, e2) {
      let a, i, r;
      a = [].concat(v.chartData.yAxisData.ranges[t13.index]);
      i = a.pop();
      r = a.shift();
      var o = t13.data;
      var n = getDataPoints(o, i, r, b, S, v, m, D);
      if (t13.type !== "column") {
        drawPointText(n, t13, m, T, v);
      } else {
        n = fixColumeData(n, S, k, _, m, v);
        drawPointText(n, t13, m, T, v);
        _ += 1;
      }
    });
  }
  T.restore();
  return { xAxisPoints: b, calPoints: F, eachSpacing: S };
}
function drawToolTipBridge(t12, e, a, i, r, o) {
  var n = t12.extra.tooltip || {};
  if (n.horizentalLine && t12.tooltip && i === 1 && (t12.type == "line" || t12.type == "area" || t12.type == "column" || t12.type == "mount" || t12.type == "candle" || t12.type == "mix")) {
    drawToolTipHorizentalLine(t12, e, a);
  }
  a.save();
  if (t12._scrollDistance_ && t12._scrollDistance_ !== 0 && t12.enableScroll === true) {
    a.translate(t12._scrollDistance_, 0);
  }
  if (t12.tooltip && t12.tooltip.textList && t12.tooltip.textList.length && i === 1) {
    drawToolTip(t12.tooltip.textList, t12.tooltip.offset, t12, e, a);
  }
  a.restore();
}
function drawXAxis(r, h, c, d) {
  let e = h.chartData.xAxisData, x = e.xAxisPoints, t12 = e.startX, a = e.endX, f = e.eachSpacing;
  var p = "center";
  if (h.type == "bar" || h.type == "line" || h.type == "area" || h.type == "scatter" || h.type == "bubble") {
    p = h.xAxis.boundaryGap;
  }
  var u = h.height - h.area[2];
  var i = h.area[0];
  if (h.enableScroll && h.xAxis.scrollShow) {
    var o = h.height - h.area[2] + c.xAxisHeight;
    var n = a - t12;
    var l = f * (x.length - 1);
    if (h.type == "mount" && h.extra && h.extra.mount && h.extra.mount.widthRatio && h.extra.mount.widthRatio > 1) {
      if (h.extra.mount.widthRatio > 2)
        h.extra.mount.widthRatio = 2;
      l += (h.extra.mount.widthRatio - 1) * f;
    }
    var s = n * n / l;
    var y = 0;
    if (h._scrollDistance_) {
      y = -h._scrollDistance_ * n / l;
    }
    d.beginPath();
    d.setLineCap("round");
    d.setLineWidth(6 * h.pix);
    d.setStrokeStyle(h.xAxis.scrollBackgroundColor || "#EFEBEF");
    d.moveTo(t12, o);
    d.lineTo(a, o);
    d.stroke();
    d.closePath();
    d.beginPath();
    d.setLineCap("round");
    d.setLineWidth(6 * h.pix);
    d.setStrokeStyle(h.xAxis.scrollColor || "#A6A6A6");
    d.moveTo(t12 + y, o);
    d.lineTo(t12 + y + s, o);
    d.stroke();
    d.closePath();
    d.setLineCap("butt");
  }
  d.save();
  if (h._scrollDistance_ && h._scrollDistance_ !== 0) {
    d.translate(h._scrollDistance_, 0);
  }
  if (h.xAxis.calibration === true) {
    d.setStrokeStyle(h.xAxis.gridColor || "#cccccc");
    d.setLineCap("butt");
    d.setLineWidth(1 * h.pix);
    x.forEach(function(t13, e2) {
      if (e2 > 0) {
        d.beginPath();
        d.moveTo(t13 - f / 2, u);
        d.lineTo(t13 - f / 2, u + 3 * h.pix);
        d.closePath();
        d.stroke();
      }
    });
  }
  if (h.xAxis.disableGrid !== true) {
    d.setStrokeStyle(h.xAxis.gridColor || "#cccccc");
    d.setLineCap("butt");
    d.setLineWidth(1 * h.pix);
    if (h.xAxis.gridType == "dash") {
      d.setLineDash([h.xAxis.dashLength * h.pix, h.xAxis.dashLength * h.pix]);
    }
    h.xAxis.gridEval = h.xAxis.gridEval || 1;
    x.forEach(function(t13, e2) {
      if (e2 % h.xAxis.gridEval == 0) {
        d.beginPath();
        d.moveTo(t13, u);
        d.lineTo(t13, i);
        d.stroke();
      }
    });
    d.setLineDash([]);
  }
  if (h.xAxis.disabled !== true) {
    let t13 = r.length;
    if (h.xAxis.labelCount) {
      if (h.xAxis.itemCount) {
        t13 = Math.ceil(r.length / h.xAxis.itemCount * h.xAxis.labelCount);
      } else {
        t13 = h.xAxis.labelCount;
      }
      t13 -= 1;
    }
    let e2 = Math.ceil(r.length / t13);
    let a2 = [];
    let i2 = r.length;
    for (let t14 = 0; t14 < i2; t14++) {
      if (t14 % e2 !== 0) {
        a2.push("");
      } else {
        a2.push(r[t14]);
      }
    }
    a2[i2 - 1] = r[i2 - 1];
    var g = h.xAxis.fontSize * h.pix || c.fontSize;
    if (c._xAxisTextAngle_ === 0) {
      a2.forEach(function(t14, e3) {
        var a3 = h.xAxis.formatter ? h.xAxis.formatter(t14, e3, h) : t14;
        var i3 = -measureText(String(a3), g, d) / 2;
        if (p == "center") {
          i3 += f / 2;
        }
        if (h.xAxis.scrollShow) {
          6 * h.pix;
        }
        var o2 = h._scrollDistance_ || 0;
        var n2 = p == "center" ? x[e3] + f / 2 : x[e3];
        if (n2 - Math.abs(o2) >= h.area[3] - 1 && n2 - Math.abs(o2) <= h.width - h.area[1] + 1) {
          d.beginPath();
          d.setFontSize(g);
          d.setFillStyle(h.xAxis.fontColor || h.fontColor);
          d.fillText(String(a3), x[e3] + i3, u + h.xAxis.marginTop * h.pix + (h.xAxis.lineHeight - h.xAxis.fontSize) * h.pix / 2 + h.xAxis.fontSize * h.pix);
          d.closePath();
          d.stroke();
        }
      });
    } else {
      a2.forEach(function(t14, e3) {
        var a3 = h.xAxis.formatter ? h.xAxis.formatter(t14) : t14;
        var i3 = h._scrollDistance_ || 0;
        var r2 = p == "center" ? x[e3] + f / 2 : x[e3];
        if (r2 - Math.abs(i3) >= h.area[3] - 1 && r2 - Math.abs(i3) <= h.width - h.area[1] + 1) {
          d.save();
          d.beginPath();
          d.setFontSize(g);
          d.setFillStyle(h.xAxis.fontColor || h.fontColor);
          var o2 = measureText(String(a3), g, d);
          var n2 = x[e3];
          if (p == "center") {
            n2 = x[e3] + f / 2;
          }
          if (h.xAxis.scrollShow) {
            6 * h.pix;
          }
          var s2 = u + h.xAxis.marginTop * h.pix + g - g * Math.abs(Math.sin(c._xAxisTextAngle_));
          if (h.xAxis.rotateAngle < 0) {
            n2 -= g / 2;
            o2 = 0;
          } else {
            n2 += g / 2;
            o2 = -o2;
          }
          d.translate(n2, s2);
          d.rotate(-1 * c._xAxisTextAngle_);
          d.fillText(String(a3), o2, 0);
          d.closePath();
          d.stroke();
          d.restore();
        }
      });
    }
  }
  d.restore();
  if (h.xAxis.title) {
    d.beginPath();
    d.setFontSize(h.xAxis.titleFontSize * h.pix);
    d.setFillStyle(h.xAxis.titleFontColor);
    d.fillText(String(h.xAxis.title), h.width - h.area[1] + h.xAxis.titleOffsetX * h.pix, h.height - h.area[2] + h.xAxis.marginTop * h.pix + (h.xAxis.lineHeight - h.xAxis.titleFontSize) * h.pix / 2 + (h.xAxis.titleFontSize + h.xAxis.titleOffsetY) * h.pix);
    d.closePath();
    d.stroke();
  }
  if (h.xAxis.axisLine) {
    d.beginPath();
    d.setStrokeStyle(h.xAxis.axisLineColor);
    d.setLineWidth(1 * h.pix);
    d.moveTo(t12, h.height - h.area[2]);
    d.lineTo(a, h.height - h.area[2]);
    d.stroke();
  }
}
function drawYAxisGrid(c, e, d, a) {
  if (e.yAxis.disableGrid === true) {
    return;
  }
  let t12 = e.height - e.area[0] - e.area[2];
  let i = t12 / e.yAxis.splitNumber;
  let r = e.area[3];
  let o = e.chartData.xAxisData.xAxisPoints, n = e.chartData.xAxisData.eachSpacing;
  let l = n * (o.length - 1);
  if (e.type == "mount" && e.extra && e.extra.mount && e.extra.mount.widthRatio && e.extra.mount.widthRatio > 1) {
    if (e.extra.mount.widthRatio > 2)
      e.extra.mount.widthRatio = 2;
    l += (e.extra.mount.widthRatio - 1) * n;
  }
  let x = r + l;
  let s = [];
  let h = 1;
  if (e.xAxis.axisLine === false) {
    h = 0;
  }
  for (let t13 = h; t13 < e.yAxis.splitNumber + 1; t13++) {
    s.push(e.height - e.area[2] - i * t13);
  }
  a.save();
  if (e._scrollDistance_ && e._scrollDistance_ !== 0) {
    a.translate(e._scrollDistance_, 0);
  }
  if (e.yAxis.gridType == "dash") {
    a.setLineDash([e.yAxis.dashLength * e.pix, e.yAxis.dashLength * e.pix]);
  }
  a.setStrokeStyle(e.yAxis.gridColor);
  a.setLineWidth(1 * e.pix);
  s.forEach(function(t13, e2) {
    a.beginPath();
    a.moveTo(r, t13);
    a.lineTo(x, t13);
    a.stroke();
  });
  a.setLineDash([]);
  a.restore();
}
function drawYAxis(e, h, a, c) {
  if (h.yAxis.disabled === true) {
    return;
  }
  var i = h.height - h.area[0] - h.area[2];
  var r = i / h.yAxis.splitNumber;
  var o = h.area[3];
  var n = h.width - h.area[1];
  var t12 = h.height - h.area[2];
  c.beginPath();
  c.setFillStyle(h.background);
  if (h.enableScroll == true && h.xAxis.scrollPosition && h.xAxis.scrollPosition !== "left") {
    c.fillRect(0, 0, o, t12 + 2 * h.pix);
  }
  if (h.enableScroll == true && h.xAxis.scrollPosition && h.xAxis.scrollPosition !== "right") {
    c.fillRect(n, 0, h.width, t12 + 2 * h.pix);
  }
  c.closePath();
  c.stroke();
  let d = h.area[3];
  let x = h.width - h.area[1];
  let f = h.area[3] + (h.width - h.area[1] - h.area[3]) / 2;
  if (h.yAxis.data) {
    for (let e2 = 0; e2 < h.yAxis.data.length; e2++) {
      let s = h.yAxis.data[e2];
      var p = [];
      if (s.type === "categories") {
        for (let t13 = 0; t13 <= s.categories.length; t13++) {
          p.push(h.area[0] + i / s.categories.length / 2 + i / s.categories.length * t13);
        }
      } else {
        for (let t13 = 0; t13 <= h.yAxis.splitNumber; t13++) {
          p.push(h.area[0] + r * t13);
        }
      }
      if (s.disabled !== true) {
        let t13 = h.chartData.yAxisData.rangesFormat[e2];
        let o2 = s.fontSize ? s.fontSize * h.pix : a.fontSize;
        let n2 = h.chartData.yAxisData.yAxisWidth[e2];
        let l = s.textAlign || "right";
        t13.forEach(function(t14, e3) {
          var a2 = p[e3];
          c.beginPath();
          c.setFontSize(o2);
          c.setLineWidth(1 * h.pix);
          c.setStrokeStyle(s.axisLineColor || "#cccccc");
          c.setFillStyle(s.fontColor || h.fontColor);
          let i2 = 0;
          let r2 = 4 * h.pix;
          if (n2.position == "left") {
            if (s.calibration == true) {
              c.moveTo(d, a2);
              c.lineTo(d - 3 * h.pix, a2);
              r2 += 3 * h.pix;
            }
            switch (l) {
              case "left":
                c.setTextAlign("left");
                i2 = d - n2.width;
                break;
              case "right":
                c.setTextAlign("right");
                i2 = d - r2;
                break;
              default:
                c.setTextAlign("center");
                i2 = d - n2.width / 2;
            }
            c.fillText(String(t14), i2, a2 + o2 / 2 - 3 * h.pix);
          } else if (n2.position == "right") {
            if (s.calibration == true) {
              c.moveTo(x, a2);
              c.lineTo(x + 3 * h.pix, a2);
              r2 += 3 * h.pix;
            }
            switch (l) {
              case "left":
                c.setTextAlign("left");
                i2 = x + r2;
                break;
              case "right":
                c.setTextAlign("right");
                i2 = x + n2.width;
                break;
              default:
                c.setTextAlign("center");
                i2 = x + n2.width / 2;
            }
            c.fillText(String(t14), i2, a2 + o2 / 2 - 3 * h.pix);
          } else if (n2.position == "center") {
            if (s.calibration == true) {
              c.moveTo(f, a2);
              c.lineTo(f - 3 * h.pix, a2);
              r2 += 3 * h.pix;
            }
            switch (l) {
              case "left":
                c.setTextAlign("left");
                i2 = f - n2.width;
                break;
              case "right":
                c.setTextAlign("right");
                i2 = f - r2;
                break;
              default:
                c.setTextAlign("center");
                i2 = f - n2.width / 2;
            }
            c.fillText(String(t14), i2, a2 + o2 / 2 - 3 * h.pix);
          }
          c.closePath();
          c.stroke();
          c.setTextAlign("left");
        });
        if (s.axisLine !== false) {
          c.beginPath();
          c.setStrokeStyle(s.axisLineColor || "#cccccc");
          c.setLineWidth(1 * h.pix);
          if (n2.position == "left") {
            c.moveTo(d, h.height - h.area[2]);
            c.lineTo(d, h.area[0]);
          } else if (n2.position == "right") {
            c.moveTo(x, h.height - h.area[2]);
            c.lineTo(x, h.area[0]);
          } else if (n2.position == "center") {
            c.moveTo(f, h.height - h.area[2]);
            c.lineTo(f, h.area[0]);
          }
          c.stroke();
        }
        if (h.yAxis.showTitle) {
          let t14 = s.titleFontSize * h.pix || a.fontSize;
          let e3 = s.title;
          c.beginPath();
          c.setFontSize(t14);
          c.setFillStyle(s.titleFontColor || h.fontColor);
          if (n2.position == "left") {
            c.fillText(e3, d - measureText(e3, t14, c) / 2 + (s.titleOffsetX || 0), h.area[0] - (10 - (s.titleOffsetY || 0)) * h.pix);
          } else if (n2.position == "right") {
            c.fillText(e3, x - measureText(e3, t14, c) / 2 + (s.titleOffsetX || 0), h.area[0] - (10 - (s.titleOffsetY || 0)) * h.pix);
          } else if (n2.position == "center") {
            c.fillText(e3, f - measureText(e3, t14, c) / 2 + (s.titleOffsetX || 0), h.area[0] - (10 - (s.titleOffsetY || 0)) * h.pix);
          }
          c.closePath();
          c.stroke();
        }
        if (n2.position == "left") {
          d -= n2.width + h.yAxis.padding * h.pix;
        } else {
          x += n2.width + h.yAxis.padding * h.pix;
        }
      }
    }
  }
}
function drawLegend(t12, l, y, s, e) {
  if (l.legend.show === false) {
    return;
  }
  let h = e.legendData;
  let a = h.points;
  let c = h.area;
  let d = l.legend.padding * l.pix;
  let x = l.legend.fontSize * l.pix;
  let f = 15 * l.pix;
  let p = 5 * l.pix;
  let u = l.legend.itemGap * l.pix;
  let g = Math.max(l.legend.lineHeight * l.pix, x);
  s.beginPath();
  s.setLineWidth(l.legend.borderWidth * l.pix);
  s.setStrokeStyle(l.legend.borderColor);
  s.setFillStyle(l.legend.backgroundColor);
  s.moveTo(c.start.x, c.start.y);
  s.rect(c.start.x, c.start.y, c.width, c.height);
  s.closePath();
  s.fill();
  s.stroke();
  a.forEach(function(i, t13) {
    let e2 = 0;
    let a2 = 0;
    e2 = h.widthArr[t13];
    a2 = h.heightArr[t13];
    let r = 0;
    let o = 0;
    if (l.legend.position == "top" || l.legend.position == "bottom") {
      switch (l.legend.float) {
        case "left":
          r = c.start.x + d;
          break;
        case "right":
          r = c.start.x + c.width - e2;
          break;
        default:
          r = c.start.x + (c.width - e2) / 2;
      }
      o = c.start.y + d + t13 * g;
    } else {
      if (t13 == 0) {
        e2 = 0;
      } else {
        e2 = h.widthArr[t13 - 1];
      }
      r = c.start.x + d + e2;
      o = c.start.y + d + (c.height - a2) / 2;
    }
    s.setFontSize(y.fontSize);
    for (let a3 = 0; a3 < i.length; a3++) {
      let t14 = i[a3];
      t14.area = [0, 0, 0, 0];
      t14.area[0] = r;
      t14.area[1] = o;
      t14.area[3] = o + g;
      s.beginPath();
      s.setLineWidth(1 * l.pix);
      s.setStrokeStyle(t14.show ? t14.color : l.legend.hiddenColor);
      s.setFillStyle(t14.show ? t14.color : l.legend.hiddenColor);
      switch (t14.legendShape) {
        case "line":
          s.moveTo(r, o + 0.5 * g - 2 * l.pix);
          s.fillRect(r, o + 0.5 * g - 2 * l.pix, 15 * l.pix, 4 * l.pix);
          break;
        case "triangle":
          s.moveTo(r + 7.5 * l.pix, o + 0.5 * g - 5 * l.pix);
          s.lineTo(r + 2.5 * l.pix, o + 0.5 * g + 5 * l.pix);
          s.lineTo(r + 12.5 * l.pix, o + 0.5 * g + 5 * l.pix);
          s.lineTo(r + 7.5 * l.pix, o + 0.5 * g - 5 * l.pix);
          break;
        case "diamond":
          s.moveTo(r + 7.5 * l.pix, o + 0.5 * g - 5 * l.pix);
          s.lineTo(r + 2.5 * l.pix, o + 0.5 * g);
          s.lineTo(r + 7.5 * l.pix, o + 0.5 * g + 5 * l.pix);
          s.lineTo(r + 12.5 * l.pix, o + 0.5 * g);
          s.lineTo(r + 7.5 * l.pix, o + 0.5 * g - 5 * l.pix);
          break;
        case "circle":
          s.moveTo(r + 7.5 * l.pix, o + 0.5 * g);
          s.arc(r + 7.5 * l.pix, o + 0.5 * g, 5 * l.pix, 0, 2 * Math.PI);
          break;
        case "rect":
          s.moveTo(r, o + 0.5 * g - 5 * l.pix);
          s.fillRect(r, o + 0.5 * g - 5 * l.pix, 15 * l.pix, 10 * l.pix);
          break;
        case "square":
          s.moveTo(r + 5 * l.pix, o + 0.5 * g - 5 * l.pix);
          s.fillRect(r + 5 * l.pix, o + 0.5 * g - 5 * l.pix, 10 * l.pix, 10 * l.pix);
          break;
        case "none":
          break;
        default:
          s.moveTo(r, o + 0.5 * g - 5 * l.pix);
          s.fillRect(r, o + 0.5 * g - 5 * l.pix, 15 * l.pix, 10 * l.pix);
      }
      s.closePath();
      s.fill();
      s.stroke();
      r += f + p;
      let e3 = 0.5 * g + 0.5 * x - 2;
      const n = t14.legendText ? t14.legendText : t14.name;
      s.beginPath();
      s.setFontSize(x);
      s.setFillStyle(t14.show ? l.legend.fontColor : l.legend.hiddenColor);
      s.fillText(n, r, o + e3);
      s.closePath();
      s.stroke();
      if (l.legend.position == "top" || l.legend.position == "bottom") {
        r += measureText(n, x, s) + u;
        t14.area[2] = r;
      } else {
        t14.area[2] = r + measureText(n, x, s) + u;
        r -= f + p;
        o += g;
      }
    }
  });
}
function drawPieDataPoints(t12, r, e, o) {
  var a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1;
  var n = assign({}, { activeOpacity: 0.5, activeRadius: 10, offsetAngle: 0, labelWidth: 15, ringWidth: 30, customRadius: 0, border: false, borderWidth: 2, borderColor: "#FFFFFF", centerColor: "#FFFFFF", linearType: "none", customColor: [] }, r.type == "pie" ? r.extra.pie : r.extra.ring);
  var l = { x: r.area[3] + (r.width - r.area[1] - r.area[3]) / 2, y: r.area[0] + (r.height - r.area[0] - r.area[2]) / 2 };
  if (e.pieChartLinePadding == 0) {
    e.pieChartLinePadding = n.activeRadius * r.pix;
  }
  var i = Math.min((r.width - r.area[1] - r.area[3]) / 2 - e.pieChartLinePadding - e.pieChartTextPadding - e._pieTextMaxLength_, (r.height - r.area[0] - r.area[2]) / 2 - e.pieChartLinePadding - e.pieChartTextPadding);
  i = i < 10 ? 10 : i;
  if (n.customRadius > 0) {
    i = n.customRadius * r.pix;
  }
  t12 = getPieDataPoints(t12, i, a);
  var h = n.activeRadius * r.pix;
  n.customColor = fillCustomColor(n.linearType, n.customColor, t12, e);
  t12 = t12.map(function(t13) {
    t13._start_ += n.offsetAngle * Math.PI / 180;
    return t13;
  });
  t12.forEach(function(t13, e2) {
    if (r.tooltip) {
      if (r.tooltip.index == e2) {
        o.beginPath();
        o.setFillStyle(hexToRgb(t13.color, n.activeOpacity || 0.5));
        o.moveTo(l.x, l.y);
        o.arc(l.x, l.y, t13._radius_ + h, t13._start_, t13._start_ + 2 * t13._proportion_ * Math.PI);
        o.closePath();
        o.fill();
      }
    }
    o.beginPath();
    o.setLineWidth(n.borderWidth * r.pix);
    o.lineJoin = "round";
    o.setStrokeStyle(n.borderColor);
    var a2 = t13.color;
    if (n.linearType == "custom") {
      var i2;
      if (o.createCircularGradient) {
        i2 = o.createCircularGradient(l.x, l.y, t13._radius_);
      } else {
        i2 = o.createRadialGradient(l.x, l.y, 0, l.x, l.y, t13._radius_);
      }
      i2.addColorStop(0, hexToRgb(n.customColor[t13.linearIndex], 1));
      i2.addColorStop(1, hexToRgb(t13.color, 1));
      a2 = i2;
    }
    o.setFillStyle(a2);
    o.moveTo(l.x, l.y);
    o.arc(l.x, l.y, t13._radius_, t13._start_, t13._start_ + 2 * t13._proportion_ * Math.PI);
    o.closePath();
    o.fill();
    if (n.border == true) {
      o.stroke();
    }
  });
  if (r.type === "ring") {
    var s = i * 0.6;
    if (typeof n.ringWidth === "number" && n.ringWidth > 0) {
      s = Math.max(0, i - n.ringWidth * r.pix);
    }
    o.beginPath();
    o.setFillStyle(n.centerColor);
    o.moveTo(l.x, l.y);
    o.arc(l.x, l.y, s, 0, 2 * Math.PI);
    o.closePath();
    o.fill();
  }
  if (r.dataLabel !== false && a === 1) {
    drawPieText(t12, r, e, o, i, l);
  }
  if (a === 1 && r.type === "ring") {
    drawRingTitle(r, e, o, l);
  }
  return { center: l, radius: i, series: t12 };
}
function drawRoseDataPoints(t12, r, e, o) {
  var a = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1;
  var n = assign({}, { type: "area", activeOpacity: 0.5, activeRadius: 10, offsetAngle: 0, labelWidth: 15, border: false, borderWidth: 2, borderColor: "#FFFFFF", linearType: "none", customColor: [] }, r.extra.rose);
  if (e.pieChartLinePadding == 0) {
    e.pieChartLinePadding = n.activeRadius * r.pix;
  }
  var l = { x: r.area[3] + (r.width - r.area[1] - r.area[3]) / 2, y: r.area[0] + (r.height - r.area[0] - r.area[2]) / 2 };
  var i = Math.min((r.width - r.area[1] - r.area[3]) / 2 - e.pieChartLinePadding - e.pieChartTextPadding - e._pieTextMaxLength_, (r.height - r.area[0] - r.area[2]) / 2 - e.pieChartLinePadding - e.pieChartTextPadding);
  i = i < 10 ? 10 : i;
  var s = n.minRadius || i * 0.5;
  if (i < s) {
    i = s + 10;
  }
  t12 = getRoseDataPoints(t12, n.type, s, i, a);
  var h = n.activeRadius * r.pix;
  n.customColor = fillCustomColor(n.linearType, n.customColor, t12, e);
  t12 = t12.map(function(t13) {
    t13._start_ += (n.offsetAngle || 0) * Math.PI / 180;
    return t13;
  });
  t12.forEach(function(t13, e2) {
    if (r.tooltip) {
      if (r.tooltip.index == e2) {
        o.beginPath();
        o.setFillStyle(hexToRgb(t13.color, n.activeOpacity || 0.5));
        o.moveTo(l.x, l.y);
        o.arc(l.x, l.y, h + t13._radius_, t13._start_, t13._start_ + 2 * t13._rose_proportion_ * Math.PI);
        o.closePath();
        o.fill();
      }
    }
    o.beginPath();
    o.setLineWidth(n.borderWidth * r.pix);
    o.lineJoin = "round";
    o.setStrokeStyle(n.borderColor);
    var a2 = t13.color;
    if (n.linearType == "custom") {
      var i2;
      if (o.createCircularGradient) {
        i2 = o.createCircularGradient(l.x, l.y, t13._radius_);
      } else {
        i2 = o.createRadialGradient(l.x, l.y, 0, l.x, l.y, t13._radius_);
      }
      i2.addColorStop(0, hexToRgb(n.customColor[t13.linearIndex], 1));
      i2.addColorStop(1, hexToRgb(t13.color, 1));
      a2 = i2;
    }
    o.setFillStyle(a2);
    o.moveTo(l.x, l.y);
    o.arc(l.x, l.y, t13._radius_, t13._start_, t13._start_ + 2 * t13._rose_proportion_ * Math.PI);
    o.closePath();
    o.fill();
    if (n.border == true) {
      o.stroke();
    }
  });
  if (r.dataLabel !== false && a === 1) {
    drawPieText(t12, r, e, o, i, l);
  }
  return { center: l, radius: i, series: t12 };
}
function drawArcbarDataPoints(a, i, t12, r) {
  var e = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1;
  var o = assign({}, { startAngle: 0.75, endAngle: 0.25, type: "default", direction: "cw", lineCap: "round", width: 12, gap: 2, linearType: "none", customColor: [] }, i.extra.arcbar);
  a = getArcbarDataPoints(a, o, e);
  var n;
  if (o.centerX || o.centerY) {
    n = { x: o.centerX ? o.centerX : i.width / 2, y: o.centerY ? o.centerY : i.height / 2 };
  } else {
    n = { x: i.width / 2, y: i.height / 2 };
  }
  var l;
  if (o.radius) {
    l = o.radius;
  } else {
    l = Math.min(n.x, n.y);
    l -= 5 * i.pix;
    l -= o.width / 2;
  }
  l = l < 10 ? 10 : l;
  o.customColor = fillCustomColor(o.linearType, o.customColor, a, t12);
  for (let e2 = 0; e2 < a.length; e2++) {
    let t13 = a[e2];
    r.setLineWidth(o.width * i.pix);
    r.setStrokeStyle(o.backgroundColor || "#E9E9E9");
    r.setLineCap(o.lineCap);
    r.beginPath();
    if (o.type == "default") {
      r.arc(n.x, n.y, l - (o.width * i.pix + o.gap * i.pix) * e2, o.startAngle * Math.PI, o.endAngle * Math.PI, o.direction == "ccw");
    } else {
      r.arc(n.x, n.y, l - (o.width * i.pix + o.gap * i.pix) * e2, 0, 2 * Math.PI, o.direction == "ccw");
    }
    r.stroke();
    var s = t13.color;
    if (o.linearType == "custom") {
      var h = r.createLinearGradient(n.x - l, n.y, n.x + l, n.y);
      h.addColorStop(1, hexToRgb(o.customColor[t13.linearIndex], 1));
      h.addColorStop(0, hexToRgb(t13.color, 1));
      s = h;
    }
    r.setLineWidth(o.width * i.pix);
    r.setStrokeStyle(s);
    r.setLineCap(o.lineCap);
    r.beginPath();
    r.arc(n.x, n.y, l - (o.width * i.pix + o.gap * i.pix) * e2, o.startAngle * Math.PI, t13._proportion_ * Math.PI, o.direction == "ccw");
    r.stroke();
  }
  drawRingTitle(i, t12, r, n);
  return { center: n, radius: l, series: a };
}
function drawGaugeDataPoints(n, h, c, t12, d) {
  var x = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : 1;
  var f = assign({}, { type: "default", startAngle: 0.75, endAngle: 0.25, width: 15, labelOffset: 13, splitLine: { fixRadius: 0, splitNumber: 10, width: 15, color: "#FFFFFF", childNumber: 5, childWidth: 5 }, pointer: { width: 15, color: "auto" } }, c.extra.gauge);
  if (f.oldAngle == void 0) {
    f.oldAngle = f.startAngle;
  }
  if (f.oldData == void 0) {
    f.oldData = 0;
  }
  n = getGaugeAxisPoints(n, f.startAngle, f.endAngle);
  var p = { x: c.width / 2, y: c.height / 2 };
  var u = Math.min(p.x, p.y);
  u -= 5 * c.pix;
  u -= f.width / 2;
  u = u < 10 ? 10 : u;
  var g = u - f.width;
  var y = 0;
  if (f.type == "progress") {
    var v = u - f.width * 3;
    d.beginPath();
    let t13 = d.createLinearGradient(p.x, p.y - v, p.x, p.y + v);
    t13.addColorStop("0", hexToRgb(h[0].color, 0.3));
    t13.addColorStop("1.0", hexToRgb("#FFFFFF", 0.1));
    d.setFillStyle(t13);
    d.arc(p.x, p.y, v, 0, 2 * Math.PI, false);
    d.fill();
    d.setLineWidth(f.width);
    d.setStrokeStyle(hexToRgb(h[0].color, 0.3));
    d.setLineCap("round");
    d.beginPath();
    d.arc(p.x, p.y, g, f.startAngle * Math.PI, f.endAngle * Math.PI, false);
    d.stroke();
    if (f.endAngle < f.startAngle) {
      y = 2 + f.endAngle - f.startAngle;
    } else {
      y = f.startAngle - f.endAngle;
    }
    y / f.splitLine.splitNumber;
    let a = y / f.splitLine.splitNumber / f.splitLine.childNumber;
    let i = -u - f.width * 0.5 - f.splitLine.fixRadius;
    let r = -u - f.width - f.splitLine.fixRadius + f.splitLine.width;
    d.save();
    d.translate(p.x, p.y);
    d.rotate((f.startAngle - 1) * Math.PI);
    let o = f.splitLine.splitNumber * f.splitLine.childNumber + 1;
    let n2 = h[0].data * x;
    for (let t14 = 0; t14 < o; t14++) {
      d.beginPath();
      if (n2 > t14 / o) {
        d.setStrokeStyle(hexToRgb(h[0].color, 1));
      } else {
        d.setStrokeStyle(hexToRgb(h[0].color, 0.3));
      }
      d.setLineWidth(3 * c.pix);
      d.moveTo(i, 0);
      d.lineTo(r, 0);
      d.stroke();
      d.rotate(a * Math.PI);
    }
    d.restore();
    h = getGaugeArcbarDataPoints(h, f, x);
    d.setLineWidth(f.width);
    d.setStrokeStyle(h[0].color);
    d.setLineCap("round");
    d.beginPath();
    d.arc(p.x, p.y, g, f.startAngle * Math.PI, h[0]._proportion_ * Math.PI, false);
    d.stroke();
    let l = u - f.width * 2.5;
    d.save();
    d.translate(p.x, p.y);
    d.rotate((h[0]._proportion_ - 1) * Math.PI);
    d.beginPath();
    d.setLineWidth(f.width / 3);
    let s = d.createLinearGradient(0, -l * 0.6, 0, l * 0.6);
    s.addColorStop("0", hexToRgb("#FFFFFF", 0));
    s.addColorStop("0.5", hexToRgb(h[0].color, 1));
    s.addColorStop("1.0", hexToRgb("#FFFFFF", 0));
    d.setStrokeStyle(s);
    d.arc(0, 0, l, 0.85 * Math.PI, 1.15 * Math.PI, false);
    d.stroke();
    d.beginPath();
    d.setLineWidth(1);
    d.setStrokeStyle(h[0].color);
    d.setFillStyle(h[0].color);
    d.moveTo(-l - f.width / 3 / 2, -4);
    d.lineTo(-l - f.width / 3 / 2 - 4, 0);
    d.lineTo(-l - f.width / 3 / 2, 4);
    d.lineTo(-l - f.width / 3 / 2, -4);
    d.stroke();
    d.fill();
    d.restore();
  } else {
    d.setLineWidth(f.width);
    d.setLineCap("butt");
    for (let e2 = 0; e2 < n.length; e2++) {
      let t13 = n[e2];
      d.beginPath();
      d.setStrokeStyle(t13.color);
      d.arc(p.x, p.y, u, t13._startAngle_ * Math.PI, t13._endAngle_ * Math.PI, false);
      d.stroke();
    }
    d.save();
    if (f.endAngle < f.startAngle) {
      y = 2 + f.endAngle - f.startAngle;
    } else {
      y = f.startAngle - f.endAngle;
    }
    let e = y / f.splitLine.splitNumber;
    let a = y / f.splitLine.splitNumber / f.splitLine.childNumber;
    let i = -u - f.width * 0.5 - f.splitLine.fixRadius;
    let r = -u - f.width * 0.5 - f.splitLine.fixRadius + f.splitLine.width;
    let o = -u - f.width * 0.5 - f.splitLine.fixRadius + f.splitLine.childWidth;
    d.translate(p.x, p.y);
    d.rotate((f.startAngle - 1) * Math.PI);
    for (let t13 = 0; t13 < f.splitLine.splitNumber + 1; t13++) {
      d.beginPath();
      d.setStrokeStyle(f.splitLine.color);
      d.setLineWidth(2 * c.pix);
      d.moveTo(i, 0);
      d.lineTo(r, 0);
      d.stroke();
      d.rotate(e * Math.PI);
    }
    d.restore();
    d.save();
    d.translate(p.x, p.y);
    d.rotate((f.startAngle - 1) * Math.PI);
    for (let t13 = 0; t13 < f.splitLine.splitNumber * f.splitLine.childNumber + 1; t13++) {
      d.beginPath();
      d.setStrokeStyle(f.splitLine.color);
      d.setLineWidth(1 * c.pix);
      d.moveTo(i, 0);
      d.lineTo(o, 0);
      d.stroke();
      d.rotate(a * Math.PI);
    }
    d.restore();
    h = getGaugeDataPoints(h, n, f, x);
    for (let e2 = 0; e2 < h.length; e2++) {
      let t13 = h[e2];
      d.save();
      d.translate(p.x, p.y);
      d.rotate((t13._proportion_ - 1) * Math.PI);
      d.beginPath();
      d.setFillStyle(t13.color);
      d.moveTo(f.pointer.width, 0);
      d.lineTo(0, -f.pointer.width / 2);
      d.lineTo(-g, 0);
      d.lineTo(0, f.pointer.width / 2);
      d.lineTo(f.pointer.width, 0);
      d.closePath();
      d.fill();
      d.beginPath();
      d.setFillStyle("#FFFFFF");
      d.arc(0, 0, f.pointer.width / 6, 0, 2 * Math.PI, false);
      d.fill();
      d.restore();
    }
    if (c.dataLabel !== false) {
      drawGaugeLabel(f, u, p, c, t12, d);
    }
  }
  drawRingTitle(c, t12, d, p);
  if (x === 1 && c.type === "gauge") {
    c.extra.gauge.oldAngle = h[0]._proportion_;
    c.extra.gauge.oldData = h[0].data;
  }
  return { center: p, radius: u, innerRadius: g, categories: n, totalAngle: y };
}
function drawRadarDataPoints(o, n, i, l) {
  var t12 = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1;
  var s = assign({}, { gridColor: "#cccccc", gridType: "radar", gridEval: 1, axisLabel: false, axisLabelTofix: 0, labelShow: true, labelColor: "#666666", labelPointShow: false, labelPointRadius: 3, labelPointColor: "#cccccc", opacity: 0.2, gridCount: 3, border: false, borderWidth: 2, linearType: "none", customColor: [] }, n.extra.radar);
  var a = getRadarCoordinateSeries(n.categories.length);
  var h = { x: n.area[3] + (n.width - n.area[1] - n.area[3]) / 2, y: n.area[0] + (n.height - n.area[0] - n.area[2]) / 2 };
  var r = (n.width - n.area[1] - n.area[3]) / 2;
  var d = (n.height - n.area[0] - n.area[2]) / 2;
  var c = Math.min(r - (getMaxTextListLength(n.categories, i.fontSize, l) + i.radarLabelTextMargin), d - i.radarLabelTextMargin);
  c -= i.radarLabelTextMargin * n.pix;
  c = c < 10 ? 10 : c;
  c = s.radius ? s.radius : c;
  l.beginPath();
  l.setLineWidth(1 * n.pix);
  l.setStrokeStyle(s.gridColor);
  a.forEach(function(t13, e2) {
    var a2 = convertCoordinateOrigin(c * Math.cos(t13), c * Math.sin(t13), h);
    l.moveTo(h.x, h.y);
    if (e2 % s.gridEval == 0) {
      l.lineTo(a2.x, a2.y);
    }
  });
  l.stroke();
  l.closePath();
  var x = function t13(i2) {
    var r2 = {};
    l.beginPath();
    l.setLineWidth(1 * n.pix);
    l.setStrokeStyle(s.gridColor);
    if (s.gridType == "radar") {
      a.forEach(function(t14, e3) {
        var a2 = convertCoordinateOrigin(c / s.gridCount * i2 * Math.cos(t14), c / s.gridCount * i2 * Math.sin(t14), h);
        if (e3 === 0) {
          r2 = a2;
          l.moveTo(a2.x, a2.y);
        } else {
          l.lineTo(a2.x, a2.y);
        }
      });
      l.lineTo(r2.x, r2.y);
    } else {
      var e2 = convertCoordinateOrigin(c / s.gridCount * i2 * Math.cos(1.5), c / s.gridCount * i2 * Math.sin(1.5), h);
      l.arc(h.x, h.y, h.y - e2.y, 0, 2 * Math.PI, false);
    }
    l.stroke();
    l.closePath();
  };
  for (var e = 1; e <= s.gridCount; e++) {
    x(e);
  }
  s.customColor = fillCustomColor(s.linearType, s.customColor, o, i);
  var f = getRadarDataPoints(a, h, c, o, n, t12);
  f.forEach(function(t13, e2) {
    l.beginPath();
    l.setLineWidth(s.borderWidth * n.pix);
    l.setStrokeStyle(t13.color);
    var a2 = hexToRgb(t13.color, s.opacity);
    if (s.linearType == "custom") {
      var i2;
      if (l.createCircularGradient) {
        i2 = l.createCircularGradient(h.x, h.y, c);
      } else {
        i2 = l.createRadialGradient(h.x, h.y, 0, h.x, h.y, c);
      }
      i2.addColorStop(0, hexToRgb(s.customColor[o[e2].linearIndex], s.opacity));
      i2.addColorStop(1, hexToRgb(t13.color, s.opacity));
      a2 = i2;
    }
    l.setFillStyle(a2);
    t13.data.forEach(function(t14, e3) {
      if (e3 === 0) {
        l.moveTo(t14.position.x, t14.position.y);
      } else {
        l.lineTo(t14.position.x, t14.position.y);
      }
    });
    l.closePath();
    l.fill();
    if (s.border === true) {
      l.stroke();
    }
    l.closePath();
    if (n.dataPointShape !== false) {
      var r2 = t13.data.map(function(t14) {
        return t14.position;
      });
      drawPointShape(r2, t13.color, t13.pointShape, l, n);
    }
  });
  if (s.axisLabel === true) {
    const p = Math.max(s.max, Math.max.apply(null, dataCombine(o)));
    const u = c / s.gridCount;
    const g = n.fontSize * n.pix;
    l.setFontSize(g);
    l.setFillStyle(n.fontColor);
    l.setTextAlign("left");
    for (var e = 0; e < s.gridCount + 1; e++) {
      let t13 = e * p / s.gridCount;
      t13 = t13.toFixed(s.axisLabelTofix);
      l.fillText(String(t13), h.x + 3 * n.pix, h.y - e * u + g / 2);
    }
  }
  drawRadarLabel(a, c, h, n, i, l);
  if (n.dataLabel !== false && t12 === 1) {
    f.forEach(function(t13, e2) {
      l.beginPath();
      var a2 = t13.textSize * n.pix || i.fontSize;
      l.setFontSize(a2);
      l.setFillStyle(t13.textColor || n.fontColor);
      t13.data.forEach(function(t14, e3) {
        if (Math.abs(t14.position.x - h.x) < 2) {
          if (t14.position.y < h.y) {
            l.setTextAlign("center");
            l.fillText(t14.value, t14.position.x, t14.position.y - 4);
          } else {
            l.setTextAlign("center");
            l.fillText(t14.value, t14.position.x, t14.position.y + a2 + 2);
          }
        } else {
          if (t14.position.x < h.x) {
            l.setTextAlign("right");
            l.fillText(t14.value, t14.position.x - 4, t14.position.y + a2 / 2 - 2);
          } else {
            l.setTextAlign("left");
            l.fillText(t14.value, t14.position.x + 4, t14.position.y + a2 / 2 - 2);
          }
        }
      });
      l.closePath();
      l.stroke();
    });
    l.setTextAlign("left");
  }
  return { center: h, radius: c, angleList: a };
}
function lonlat2mercator(t12, e) {
  var a = Array(2);
  var i = t12 * 2003750834e-2 / 180;
  var r = Math.log(Math.tan((90 + e) * Math.PI / 360)) / (Math.PI / 180);
  r = r * 2003750834e-2 / 180;
  a[0] = i;
  a[1] = r;
  return a;
}
function getBoundingBox(t12) {
  var e = {}, a;
  e.xMin = 180;
  e.xMax = 0;
  e.yMin = 90;
  e.yMax = 0;
  for (var i = 0; i < t12.length; i++) {
    var r = t12[i].geometry.coordinates;
    for (var o = 0; o < r.length; o++) {
      a = r[o];
      if (a.length == 1) {
        a = a[0];
      }
      for (var n = 0; n < a.length; n++) {
        var l = a[n][0];
        var s = a[n][1];
        var h = { x: l, y: s };
        e.xMin = e.xMin < h.x ? e.xMin : h.x;
        e.xMax = e.xMax > h.x ? e.xMax : h.x;
        e.yMin = e.yMin < h.y ? e.yMin : h.y;
        e.yMax = e.yMax > h.y ? e.yMax : h.y;
      }
    }
  }
  return e;
}
function coordinateToPoint(t12, e, a, i, r, o) {
  return { x: (e - a.xMin) * i + r, y: (a.yMax - t12) * i + o };
}
function pointToCoordinate(t12, e, a, i, r, o) {
  return { x: (e - r) / i + a.xMin, y: a.yMax - (t12 - o) / i };
}
function isRayIntersectsSegment(t12, e, a) {
  if (e[1] == a[1]) {
    return false;
  }
  if (e[1] > t12[1] && a[1] > t12[1]) {
    return false;
  }
  if (e[1] < t12[1] && a[1] < t12[1]) {
    return false;
  }
  if (e[1] == t12[1] && a[1] > t12[1]) {
    return false;
  }
  if (a[1] == t12[1] && e[1] > t12[1]) {
    return false;
  }
  if (e[0] < t12[0] && a[1] < t12[1]) {
    return false;
  }
  let i = a[0] - (a[0] - e[0]) * (a[1] - t12[1]) / (a[1] - e[1]);
  if (i < t12[0]) {
    return false;
  } else {
    return true;
  }
}
function isPoiWithinPoly(r, e, o) {
  let n = 0;
  for (let t12 = 0; t12 < e.length; t12++) {
    let i = e[t12][0];
    if (e.length == 1) {
      i = e[t12][0];
    }
    for (let a = 0; a < i.length - 1; a++) {
      let t13 = i[a];
      let e2 = i[a + 1];
      if (o) {
        t13 = lonlat2mercator(i[a][0], i[a][1]);
        e2 = lonlat2mercator(i[a + 1][0], i[a + 1][1]);
      }
      if (isRayIntersectsSegment(r, t13, e2)) {
        n += 1;
      }
    }
  }
  if (n % 2 == 1) {
    return true;
  } else {
    return false;
  }
}
function drawMapDataPoints(a, i, d, r) {
  var o = assign({}, { border: true, mercator: false, borderWidth: 1, active: true, borderColor: "#666666", fillOpacity: 0.6, activeBorderColor: "#f04864", activeFillColor: "#facc14", activeFillOpacity: 1 }, i.extra.map);
  var t12, n;
  var l = a;
  var s = getBoundingBox(l);
  if (o.mercator) {
    var x = lonlat2mercator(s.xMax, s.yMax);
    var f = lonlat2mercator(s.xMin, s.yMin);
    s.xMax = x[0];
    s.yMax = x[1];
    s.xMin = f[0];
    s.yMin = f[1];
  }
  var p = i.width / Math.abs(s.xMax - s.xMin);
  var u = i.height / Math.abs(s.yMax - s.yMin);
  var h = p < u ? p : u;
  var g = i.width / 2 - Math.abs(s.xMax - s.xMin) / 2 * h;
  var y = i.height / 2 - Math.abs(s.yMax - s.yMin) / 2 * h;
  for (var c = 0; c < l.length; c++) {
    r.beginPath();
    r.setLineWidth(o.borderWidth * i.pix);
    r.setStrokeStyle(o.borderColor);
    r.setFillStyle(hexToRgb(a[c].color, a[c].fillOpacity || o.fillOpacity));
    if (o.active == true && i.tooltip) {
      if (i.tooltip.index == c) {
        r.setStrokeStyle(o.activeBorderColor);
        r.setFillStyle(hexToRgb(o.activeFillColor, o.activeFillOpacity));
      }
    }
    var v = l[c].geometry.coordinates;
    for (var m = 0; m < v.length; m++) {
      t12 = v[m];
      if (t12.length == 1) {
        t12 = t12[0];
      }
      for (var e = 0; e < t12.length; e++) {
        var T = Array(2);
        if (o.mercator) {
          T = lonlat2mercator(t12[e][0], t12[e][1]);
        } else {
          T = t12[e];
        }
        n = coordinateToPoint(T[1], T[0], s, h, g, y);
        if (e === 0) {
          r.beginPath();
          r.moveTo(n.x, n.y);
        } else {
          r.lineTo(n.x, n.y);
        }
      }
      r.fill();
      if (o.border == true) {
        r.stroke();
      }
    }
  }
  if (i.dataLabel == true) {
    for (var c = 0; c < l.length; c++) {
      var b = l[c].properties.centroid;
      if (b) {
        if (o.mercator) {
          b = lonlat2mercator(l[c].properties.centroid[0], l[c].properties.centroid[1]);
        }
        n = coordinateToPoint(b[1], b[0], s, h, g, y);
        let t13 = l[c].textSize * i.pix || d.fontSize;
        let e2 = l[c].textColor || i.fontColor;
        if (o.active && o.activeTextColor && i.tooltip && i.tooltip.index == c) {
          e2 = o.activeTextColor;
        }
        let a2 = l[c].properties.name;
        r.beginPath();
        r.setFontSize(t13);
        r.setFillStyle(e2);
        r.fillText(a2, n.x - measureText(a2, t13, r) / 2, n.y + t13 / 2);
        r.closePath();
        r.stroke();
      }
    }
  }
  i.chartData.mapData = { bounds: s, scale: h, xoffset: g, yoffset: y, mercator: o.mercator };
  drawToolTipBridge(i, d, r, 1);
  r.draw();
}
function normalInt(t12, e, a) {
  a = a == 0 ? 1 : a;
  var i = [];
  for (var r = 0; r < a; r++) {
    i[r] = Math.random();
  }
  return Math.floor(i.reduce(function(t13, e2) {
    return t13 + e2;
  }) / a * (e - t12)) + t12;
}
function collisionNew(e, a, i, r) {
  var o = false;
  for (let t12 = 0; t12 < a.length; t12++) {
    if (a[t12].area) {
      if (e[3] < a[t12].area[1] || e[0] > a[t12].area[2] || e[1] > a[t12].area[3] || e[2] < a[t12].area[0]) {
        if (e[0] < 0 || e[1] < 0 || e[2] > i || e[3] > r) {
          o = true;
          break;
        } else {
          o = false;
        }
      } else {
        o = true;
        break;
      }
    }
  }
  return o;
}
function getWordCloudPoint(c, t12, d) {
  let x = c.series;
  switch (t12) {
    case "normal":
      for (let l = 0; l < x.length; l++) {
        let t13 = x[l].name;
        let e = x[l].textSize * c.pix;
        let a = measureText(t13, e, d);
        let i, r;
        let o;
        let n = 0;
        while (true) {
          n++;
          i = normalInt(-c.width / 2, c.width / 2, 5) - a / 2;
          r = normalInt(-c.height / 2, c.height / 2, 5) + e / 2;
          o = [i - 5 + c.width / 2, r - 5 - e + c.height / 2, i + a + 5 + c.width / 2, r + 5 + c.height / 2];
          let t14 = collisionNew(o, x, c.width, c.height);
          if (!t14)
            break;
          if (n == 1e3) {
            o = [-100, -100, -100, -100];
            break;
          }
        }
        x[l].area = o;
      }
      break;
    case "vertical":
      let f = function() {
        if (Math.random() > 0.7) {
          return true;
        } else {
          return false;
        }
      };
      for (let h = 0; h < x.length; h++) {
        let t13 = x[h].name;
        let e = x[h].textSize * c.pix;
        let a = measureText(t13, e, d);
        let i = f();
        let r, o, n, l;
        let s = 0;
        while (true) {
          s++;
          let t14;
          if (i) {
            r = normalInt(-c.width / 2, c.width / 2, 5) - a / 2;
            o = normalInt(-c.height / 2, c.height / 2, 5) + e / 2;
            n = [o - 5 - a + c.width / 2, -r - 5 + c.height / 2, o + 5 + c.width / 2, -r + e + 5 + c.height / 2];
            l = [c.width - (c.width / 2 - c.height / 2) - (-r + e + 5 + c.height / 2) - 5, c.height / 2 - c.width / 2 + (o - 5 - a + c.width / 2) - 5, c.width - (c.width / 2 - c.height / 2) - (-r + e + 5 + c.height / 2) + e, c.height / 2 - c.width / 2 + (o - 5 - a + c.width / 2) + a + 5];
            t14 = collisionNew(l, x, c.height, c.width);
          } else {
            r = normalInt(-c.width / 2, c.width / 2, 5) - a / 2;
            o = normalInt(-c.height / 2, c.height / 2, 5) + e / 2;
            n = [r - 5 + c.width / 2, o - 5 - e + c.height / 2, r + a + 5 + c.width / 2, o + 5 + c.height / 2];
            t14 = collisionNew(n, x, c.width, c.height);
          }
          if (!t14)
            break;
          if (s == 1e3) {
            n = [-1e3, -1e3, -1e3, -1e3];
            break;
          }
        }
        if (i) {
          x[h].area = l;
          x[h].areav = n;
        } else {
          x[h].area = n;
        }
        x[h].rotate = i;
      }
      break;
  }
  return x;
}
function drawWordCloudDataPoints(t12, r, e, o) {
  let n = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1;
  let a = assign({}, { type: "normal", autoColors: true }, r.extra.word);
  if (!r.chartData.wordCloudData) {
    r.chartData.wordCloudData = getWordCloudPoint(r, a.type, o);
  }
  o.beginPath();
  o.setFillStyle(r.background);
  o.rect(0, 0, r.width, r.height);
  o.fill();
  o.save();
  let l = r.chartData.wordCloudData;
  o.translate(r.width / 2, r.height / 2);
  for (let i = 0; i < l.length; i++) {
    o.save();
    if (l[i].rotate) {
      o.rotate(90 * Math.PI / 180);
    }
    let t13 = l[i].name;
    let e2 = l[i].textSize * r.pix;
    let a2 = measureText(t13, e2, o);
    o.beginPath();
    o.setStrokeStyle(l[i].color);
    o.setFillStyle(l[i].color);
    o.setFontSize(e2);
    if (l[i].rotate) {
      if (l[i].areav[0] > 0) {
        if (r.tooltip) {
          if (r.tooltip.index == i) {
            o.strokeText(t13, (l[i].areav[0] + 5 - r.width / 2) * n - a2 * (1 - n) / 2, (l[i].areav[1] + 5 + e2 - r.height / 2) * n);
          } else {
            o.fillText(t13, (l[i].areav[0] + 5 - r.width / 2) * n - a2 * (1 - n) / 2, (l[i].areav[1] + 5 + e2 - r.height / 2) * n);
          }
        } else {
          o.fillText(t13, (l[i].areav[0] + 5 - r.width / 2) * n - a2 * (1 - n) / 2, (l[i].areav[1] + 5 + e2 - r.height / 2) * n);
        }
      }
    } else {
      if (l[i].area[0] > 0) {
        if (r.tooltip) {
          if (r.tooltip.index == i) {
            o.strokeText(t13, (l[i].area[0] + 5 - r.width / 2) * n - a2 * (1 - n) / 2, (l[i].area[1] + 5 + e2 - r.height / 2) * n);
          } else {
            o.fillText(t13, (l[i].area[0] + 5 - r.width / 2) * n - a2 * (1 - n) / 2, (l[i].area[1] + 5 + e2 - r.height / 2) * n);
          }
        } else {
          o.fillText(t13, (l[i].area[0] + 5 - r.width / 2) * n - a2 * (1 - n) / 2, (l[i].area[1] + 5 + e2 - r.height / 2) * n);
        }
      }
    }
    o.stroke();
    o.restore();
  }
  o.restore();
}
function drawFunnelDataPoints(t12, e, c, a) {
  let d = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : 1;
  let i = assign({}, { type: "funnel", activeWidth: 10, activeOpacity: 0.3, border: false, borderWidth: 2, borderColor: "#FFFFFF", fillOpacity: 1, minSize: 0, labelAlign: "right", linearType: "none", customColor: [] }, e.extra.funnel);
  let r = (e.height - e.area[0] - e.area[2]) / t12.length;
  let o = { x: e.area[3] + (e.width - e.area[1] - e.area[3]) / 2, y: e.height - e.area[2] };
  let n = i.activeWidth * e.pix;
  let x = Math.min((e.width - e.area[1] - e.area[3]) / 2 - n, (e.height - e.area[0] - e.area[2]) / 2 - n);
  let l = getFunnelDataPoints(t12, x, i, r, d);
  a.save();
  a.translate(o.x, o.y);
  i.customColor = fillCustomColor(i.linearType, i.customColor, t12, c);
  if (i.type == "pyramid") {
    for (let t13 = 0; t13 < l.length; t13++) {
      if (t13 == l.length - 1) {
        if (e.tooltip) {
          if (e.tooltip.index == t13) {
            a.beginPath();
            a.setFillStyle(hexToRgb(l[t13].color, i.activeOpacity));
            a.moveTo(-n, -r);
            a.lineTo(-l[t13].radius - n, 0);
            a.lineTo(l[t13].radius + n, 0);
            a.lineTo(n, -r);
            a.lineTo(-n, -r);
            a.closePath();
            a.fill();
          }
        }
        l[t13].funnelArea = [o.x - l[t13].radius, o.y - r * (t13 + 1), o.x + l[t13].radius, o.y - r * t13];
        a.beginPath();
        a.setLineWidth(i.borderWidth * e.pix);
        a.setStrokeStyle(i.borderColor);
        var s = hexToRgb(l[t13].color, i.fillOpacity);
        if (i.linearType == "custom") {
          var h = a.createLinearGradient(l[t13].radius, -r, -l[t13].radius, -r);
          h.addColorStop(0, hexToRgb(l[t13].color, i.fillOpacity));
          h.addColorStop(0.5, hexToRgb(i.customColor[l[t13].linearIndex], i.fillOpacity));
          h.addColorStop(1, hexToRgb(l[t13].color, i.fillOpacity));
          s = h;
        }
        a.setFillStyle(s);
        a.moveTo(0, -r);
        a.lineTo(-l[t13].radius, 0);
        a.lineTo(l[t13].radius, 0);
        a.lineTo(0, -r);
        a.closePath();
        a.fill();
        if (i.border == true) {
          a.stroke();
        }
      } else {
        if (e.tooltip) {
          if (e.tooltip.index == t13) {
            a.beginPath();
            a.setFillStyle(hexToRgb(l[t13].color, i.activeOpacity));
            a.moveTo(0, 0);
            a.lineTo(-l[t13].radius - n, 0);
            a.lineTo(-l[t13 + 1].radius - n, -r);
            a.lineTo(l[t13 + 1].radius + n, -r);
            a.lineTo(l[t13].radius + n, 0);
            a.lineTo(0, 0);
            a.closePath();
            a.fill();
          }
        }
        l[t13].funnelArea = [o.x - l[t13].radius, o.y - r * (t13 + 1), o.x + l[t13].radius, o.y - r * t13];
        a.beginPath();
        a.setLineWidth(i.borderWidth * e.pix);
        a.setStrokeStyle(i.borderColor);
        var s = hexToRgb(l[t13].color, i.fillOpacity);
        if (i.linearType == "custom") {
          var h = a.createLinearGradient(l[t13].radius, -r, -l[t13].radius, -r);
          h.addColorStop(0, hexToRgb(l[t13].color, i.fillOpacity));
          h.addColorStop(0.5, hexToRgb(i.customColor[l[t13].linearIndex], i.fillOpacity));
          h.addColorStop(1, hexToRgb(l[t13].color, i.fillOpacity));
          s = h;
        }
        a.setFillStyle(s);
        a.moveTo(0, 0);
        a.lineTo(-l[t13].radius, 0);
        a.lineTo(-l[t13 + 1].radius, -r);
        a.lineTo(l[t13 + 1].radius, -r);
        a.lineTo(l[t13].radius, 0);
        a.lineTo(0, 0);
        a.closePath();
        a.fill();
        if (i.border == true) {
          a.stroke();
        }
      }
      a.translate(0, -r);
    }
  } else {
    a.translate(0, -(l.length - 1) * r);
    for (let t13 = 0; t13 < l.length; t13++) {
      if (t13 == l.length - 1) {
        if (e.tooltip) {
          if (e.tooltip.index == t13) {
            a.beginPath();
            a.setFillStyle(hexToRgb(l[t13].color, i.activeOpacity));
            a.moveTo(-n - i.minSize / 2, 0);
            a.lineTo(-l[t13].radius - n, -r);
            a.lineTo(l[t13].radius + n, -r);
            a.lineTo(n + i.minSize / 2, 0);
            a.lineTo(-n - i.minSize / 2, 0);
            a.closePath();
            a.fill();
          }
        }
        l[t13].funnelArea = [o.x - l[t13].radius, o.y - r, o.x + l[t13].radius, o.y];
        a.beginPath();
        a.setLineWidth(i.borderWidth * e.pix);
        a.setStrokeStyle(i.borderColor);
        var s = hexToRgb(l[t13].color, i.fillOpacity);
        if (i.linearType == "custom") {
          var h = a.createLinearGradient(l[t13].radius, -r, -l[t13].radius, -r);
          h.addColorStop(0, hexToRgb(l[t13].color, i.fillOpacity));
          h.addColorStop(0.5, hexToRgb(i.customColor[l[t13].linearIndex], i.fillOpacity));
          h.addColorStop(1, hexToRgb(l[t13].color, i.fillOpacity));
          s = h;
        }
        a.setFillStyle(s);
        a.moveTo(0, 0);
        a.lineTo(-i.minSize / 2, 0);
        a.lineTo(-l[t13].radius, -r);
        a.lineTo(l[t13].radius, -r);
        a.lineTo(i.minSize / 2, 0);
        a.lineTo(0, 0);
        a.closePath();
        a.fill();
        if (i.border == true) {
          a.stroke();
        }
      } else {
        if (e.tooltip) {
          if (e.tooltip.index == t13) {
            a.beginPath();
            a.setFillStyle(hexToRgb(l[t13].color, i.activeOpacity));
            a.moveTo(0, 0);
            a.lineTo(-l[t13 + 1].radius - n, 0);
            a.lineTo(-l[t13].radius - n, -r);
            a.lineTo(l[t13].radius + n, -r);
            a.lineTo(l[t13 + 1].radius + n, 0);
            a.lineTo(0, 0);
            a.closePath();
            a.fill();
          }
        }
        l[t13].funnelArea = [o.x - l[t13].radius, o.y - r * (l.length - t13), o.x + l[t13].radius, o.y - r * (l.length - t13 - 1)];
        a.beginPath();
        a.setLineWidth(i.borderWidth * e.pix);
        a.setStrokeStyle(i.borderColor);
        var s = hexToRgb(l[t13].color, i.fillOpacity);
        if (i.linearType == "custom") {
          var h = a.createLinearGradient(l[t13].radius, -r, -l[t13].radius, -r);
          h.addColorStop(0, hexToRgb(l[t13].color, i.fillOpacity));
          h.addColorStop(0.5, hexToRgb(i.customColor[l[t13].linearIndex], i.fillOpacity));
          h.addColorStop(1, hexToRgb(l[t13].color, i.fillOpacity));
          s = h;
        }
        a.setFillStyle(s);
        a.moveTo(0, 0);
        a.lineTo(-l[t13 + 1].radius, 0);
        a.lineTo(-l[t13].radius, -r);
        a.lineTo(l[t13].radius, -r);
        a.lineTo(l[t13 + 1].radius, 0);
        a.lineTo(0, 0);
        a.closePath();
        a.fill();
        if (i.border == true) {
          a.stroke();
        }
      }
      a.translate(0, r);
    }
  }
  a.restore();
  if (e.dataLabel !== false && d === 1) {
    drawFunnelText(l, e, a, r, i.labelAlign, n, o);
  }
  if (d === 1) {
    drawFunnelCenterText(l, e, a, r, i.labelAlign, n, o);
  }
  return { center: o, radius: x, series: l };
}
function drawFunnelText(l, s, h, c, d, x, f) {
  for (let n = 0; n < l.length; n++) {
    let t12 = l[n];
    if (t12.labelShow === false) {
      continue;
    }
    let e, a, i, r;
    let o = t12.formatter ? t12.formatter(t12, n, l, s) : util.toFixed(t12._proportion_ * 100) + "%";
    o = t12.labelText ? t12.labelText : o;
    if (d == "right") {
      if (n == l.length - 1) {
        e = (t12.funnelArea[2] + f.x) / 2;
      } else {
        e = (t12.funnelArea[2] + l[n + 1].funnelArea[2]) / 2;
      }
      a = e + x * 2;
      i = t12.funnelArea[1] + c / 2;
      r = t12.textSize * s.pix || s.fontSize * s.pix;
      h.setLineWidth(1 * s.pix);
      h.setStrokeStyle(t12.color);
      h.setFillStyle(t12.color);
      h.beginPath();
      h.moveTo(e, i);
      h.lineTo(a, i);
      h.stroke();
      h.closePath();
      h.beginPath();
      h.moveTo(a, i);
      h.arc(a, i, 2 * s.pix, 0, 2 * Math.PI);
      h.closePath();
      h.fill();
      h.beginPath();
      h.setFontSize(r);
      h.setFillStyle(t12.textColor || s.fontColor);
      h.fillText(o, a + 5, i + r / 2 - 2);
      h.closePath();
      h.stroke();
      h.closePath();
    }
    if (d == "left") {
      if (n == l.length - 1) {
        e = (t12.funnelArea[0] + f.x) / 2;
      } else {
        e = (t12.funnelArea[0] + l[n + 1].funnelArea[0]) / 2;
      }
      a = e - x * 2;
      i = t12.funnelArea[1] + c / 2;
      r = t12.textSize * s.pix || s.fontSize * s.pix;
      h.setLineWidth(1 * s.pix);
      h.setStrokeStyle(t12.color);
      h.setFillStyle(t12.color);
      h.beginPath();
      h.moveTo(e, i);
      h.lineTo(a, i);
      h.stroke();
      h.closePath();
      h.beginPath();
      h.moveTo(a, i);
      h.arc(a, i, 2, 0, 2 * Math.PI);
      h.closePath();
      h.fill();
      h.beginPath();
      h.setFontSize(r);
      h.setFillStyle(t12.textColor || s.fontColor);
      h.fillText(o, a - 5 - measureText(o, r, h), i + r / 2 - 2);
      h.closePath();
      h.stroke();
      h.closePath();
    }
  }
}
function drawFunnelCenterText(r, o, n, l, t12, e, s) {
  for (let i = 0; i < r.length; i++) {
    let t13 = r[i];
    let e2, a;
    if (t13.centerText) {
      e2 = t13.funnelArea[1] + l / 2;
      a = t13.centerTextSize * o.pix || o.fontSize * o.pix;
      n.beginPath();
      n.setFontSize(a);
      n.setFillStyle(t13.centerTextColor || "#FFFFFF");
      n.fillText(t13.centerText, s.x - measureText(t13.centerText, a, n) / 2, e2 + a / 2 - 2);
      n.closePath();
      n.stroke();
      n.closePath();
    }
  }
}
function drawCanvas(t12, e) {
  e.save();
  e.translate(0, 0.5);
  e.restore();
  e.draw();
}
var Timing = { easeIn: function t7(e) {
  return Math.pow(e, 3);
}, easeOut: function t8(e) {
  return Math.pow(e - 1, 3) + 1;
}, easeInOut: function t9(e) {
  if ((e /= 0.5) < 1) {
    return 0.5 * Math.pow(e, 3);
  } else {
    return 0.5 * (Math.pow(e - 2, 3) + 2);
  }
}, linear: function t10(e) {
  return e;
} };
function Animation(r) {
  this.isStop = false;
  r.duration = typeof r.duration === "undefined" ? 1e3 : r.duration;
  r.timing = r.timing || "easeInOut";
  var o = 17;
  function t12() {
    if (typeof setTimeout !== "undefined") {
      return function(e, t13) {
        setTimeout(function() {
          var t14 = +/* @__PURE__ */ new Date();
          e(t14);
        }, t13);
      };
    } else if (typeof requestAnimationFrame !== "undefined") {
      return requestAnimationFrame;
    } else {
      return function(t13) {
        t13(null);
      };
    }
  }
  var n = t12();
  var l = null;
  var s = function t13(e) {
    if (e === null || this.isStop === true) {
      r.onProcess && r.onProcess(1);
      r.onAnimationFinish && r.onAnimationFinish();
      return;
    }
    if (l === null) {
      l = e;
    }
    if (e - l < r.duration) {
      var a = (e - l) / r.duration;
      var i = Timing[r.timing];
      a = i(a);
      r.onProcess && r.onProcess(a);
      n(s, o);
    } else {
      r.onProcess && r.onProcess(1);
      r.onAnimationFinish && r.onAnimationFinish();
    }
  };
  s = s.bind(this);
  n(s, o);
}
Animation.prototype.stop = function() {
  this.isStop = true;
};
function drawCharts(t12, l, n, s) {
  var h = this;
  var c = l.series;
  if (t12 === "pie" || t12 === "ring" || t12 === "mount" || t12 === "rose" || t12 === "funnel") {
    c = fixPieSeries(c, l);
  }
  var d = l.categories;
  if (t12 === "mount") {
    d = [];
    for (let t13 = 0; t13 < c.length; t13++) {
      if (c[t13].show !== false)
        d.push(c[t13].name);
    }
    l.categories = d;
  }
  c = fillSeries(c, l, n);
  var e = l.animation ? l.duration : 0;
  h.animationInstance && h.animationInstance.stop();
  var x = null;
  if (t12 == "candle") {
    let t13 = assign({}, l.extra.candle.average);
    if (t13.show) {
      x = calCandleMA(t13.day, t13.name, t13.color, c[0].data);
      x = fillSeries(x, l, n);
      l.seriesMA = x;
    } else if (l.seriesMA) {
      x = l.seriesMA = fillSeries(l.seriesMA, l, n);
    } else {
      x = c;
    }
  } else {
    x = c;
  }
  l._series_ = c = filterSeries(c);
  l.area = new Array(4);
  for (let t13 = 0; t13 < 4; t13++) {
    l.area[t13] = l.padding[t13] * l.pix;
  }
  var a = calLegendData(x, l, n, l.chartData, s), r = a.area.wholeHeight, o = a.area.wholeWidth;
  switch (l.legend.position) {
    case "top":
      l.area[0] += r;
      break;
    case "bottom":
      l.area[2] += r;
      break;
    case "left":
      l.area[3] += o;
      break;
    case "right":
      l.area[1] += o;
      break;
  }
  let f = {}, i = 0;
  if (l.type === "line" || l.type === "column" || l.type === "mount" || l.type === "area" || l.type === "mix" || l.type === "candle" || l.type === "scatter" || l.type === "bubble" || l.type === "bar") {
    f = calYAxisData(c, l, n, s);
    i = f.yAxisWidth;
    if (l.yAxis.showTitle) {
      let e3 = 0;
      for (let t13 = 0; t13 < l.yAxis.data.length; t13++) {
        e3 = Math.max(e3, l.yAxis.data[t13].titleFontSize ? l.yAxis.data[t13].titleFontSize * l.pix : n.fontSize);
      }
      l.area[0] += e3;
    }
    let e2 = 0, a2 = 0;
    for (let t13 = 0; t13 < i.length; t13++) {
      if (i[t13].position == "left") {
        if (a2 > 0) {
          l.area[3] += i[t13].width + l.yAxis.padding * l.pix;
        } else {
          l.area[3] += i[t13].width;
        }
        a2 += 1;
      } else if (i[t13].position == "right") {
        if (e2 > 0) {
          l.area[1] += i[t13].width + l.yAxis.padding * l.pix;
        } else {
          l.area[1] += i[t13].width;
        }
        e2 += 1;
      }
    }
  } else {
    n.yAxisWidth = i;
  }
  l.chartData.yAxisData = f;
  if (l.categories && l.categories.length && l.type !== "radar" && l.type !== "gauge" && l.type !== "bar") {
    l.chartData.xAxisData = getXAxisPoints(l.categories, l);
    let t13 = calCategoriesData(l.categories, l, n, l.chartData.xAxisData.eachSpacing, s), e2 = t13.xAxisHeight, a2 = t13.angle;
    n.xAxisHeight = e2;
    n._xAxisTextAngle_ = a2;
    l.area[2] += e2;
    l.chartData.categoriesData = t13;
  } else {
    if (l.type === "line" || l.type === "area" || l.type === "scatter" || l.type === "bubble" || l.type === "bar") {
      l.chartData.xAxisData = calXAxisData(c, l, n, s);
      d = l.chartData.xAxisData.rangesFormat;
      let t13 = calCategoriesData(d, l, n, l.chartData.xAxisData.eachSpacing, s), e2 = t13.xAxisHeight, a2 = t13.angle;
      n.xAxisHeight = e2;
      n._xAxisTextAngle_ = a2;
      l.area[2] += e2;
      l.chartData.categoriesData = t13;
    } else {
      l.chartData.xAxisData = { xAxisPoints: [] };
    }
  }
  if (l.enableScroll && l.xAxis.scrollAlign == "right" && l._scrollDistance_ === void 0) {
    let t13 = 0, e2 = l.chartData.xAxisData.xAxisPoints, a2 = l.chartData.xAxisData.startX, i2 = l.chartData.xAxisData.endX, r2 = l.chartData.xAxisData.eachSpacing;
    let o2 = r2 * (e2.length - 1);
    let n2 = i2 - a2;
    t13 = n2 - o2;
    h.scrollOption.currentOffset = t13;
    h.scrollOption.startTouchX = t13;
    h.scrollOption.distance = 0;
    h.scrollOption.lastMoveTime = 0;
    l._scrollDistance_ = t13;
  }
  if (t12 === "pie" || t12 === "ring" || t12 === "rose") {
    n._pieTextMaxLength_ = l.dataLabel === false ? 0 : getPieTextMaxLength(x, n, s, l);
  }
  switch (t12) {
    case "word":
      this.animationInstance = new Animation({ timing: l.timing, duration: e, onProcess: function(t13) {
        s.clearRect(0, 0, l.width, l.height);
        if (l.rotate) {
          contextRotate(s, l);
        }
        drawWordCloudDataPoints(c, l, n, s, t13);
        drawCanvas(l, s);
      }, onAnimationFinish: function t13() {
        h.uevent.trigger("renderComplete");
      } });
      break;
    case "map":
      s.clearRect(0, 0, l.width, l.height);
      drawMapDataPoints(c, l, n, s);
      setTimeout(() => {
        this.uevent.trigger("renderComplete");
      }, 50);
      break;
    case "funnel":
      this.animationInstance = new Animation({ timing: l.timing, duration: e, onProcess: function(t13) {
        s.clearRect(0, 0, l.width, l.height);
        if (l.rotate) {
          contextRotate(s, l);
        }
        l.chartData.funnelData = drawFunnelDataPoints(c, l, n, s, t13);
        drawLegend(l.series, l, n, s, l.chartData);
        drawToolTipBridge(l, n, s, t13);
        drawCanvas(l, s);
      }, onAnimationFinish: function t13() {
        h.uevent.trigger("renderComplete");
      } });
      break;
    case "line":
      this.animationInstance = new Animation({ timing: l.timing, duration: e, onProcess: function t13(e2) {
        s.clearRect(0, 0, l.width, l.height);
        if (l.rotate) {
          contextRotate(s, l);
        }
        drawYAxisGrid(d, l, n, s);
        drawXAxis(d, l, n, s);
        var a2 = drawLineDataPoints(c, l, n, s, e2), i2 = a2.xAxisPoints, r2 = a2.calPoints, o2 = a2.eachSpacing;
        l.chartData.xAxisPoints = i2;
        l.chartData.calPoints = r2;
        l.chartData.eachSpacing = o2;
        drawYAxis(c, l, n, s);
        if (l.enableMarkLine !== false && e2 === 1) {
          drawMarkLine(l, n, s);
        }
        drawLegend(l.series, l, n, s, l.chartData);
        drawToolTipBridge(l, n, s, e2);
        drawCanvas(l, s);
      }, onAnimationFinish: function t13() {
        h.uevent.trigger("renderComplete");
      } });
      break;
    case "scatter":
      this.animationInstance = new Animation({ timing: l.timing, duration: e, onProcess: function t13(e2) {
        s.clearRect(0, 0, l.width, l.height);
        if (l.rotate) {
          contextRotate(s, l);
        }
        drawYAxisGrid(d, l, n, s);
        drawXAxis(d, l, n, s);
        var a2 = drawScatterDataPoints(c, l, n, s, e2), i2 = a2.xAxisPoints, r2 = a2.calPoints, o2 = a2.eachSpacing;
        l.chartData.xAxisPoints = i2;
        l.chartData.calPoints = r2;
        l.chartData.eachSpacing = o2;
        drawYAxis(c, l, n, s);
        if (l.enableMarkLine !== false && e2 === 1) {
          drawMarkLine(l, n, s);
        }
        drawLegend(l.series, l, n, s, l.chartData);
        drawToolTipBridge(l, n, s, e2);
        drawCanvas(l, s);
      }, onAnimationFinish: function t13() {
        h.uevent.trigger("renderComplete");
      } });
      break;
    case "bubble":
      this.animationInstance = new Animation({ timing: l.timing, duration: e, onProcess: function t13(e2) {
        s.clearRect(0, 0, l.width, l.height);
        if (l.rotate) {
          contextRotate(s, l);
        }
        drawYAxisGrid(d, l, n, s);
        drawXAxis(d, l, n, s);
        var a2 = drawBubbleDataPoints(c, l, n, s, e2), i2 = a2.xAxisPoints, r2 = a2.calPoints, o2 = a2.eachSpacing;
        l.chartData.xAxisPoints = i2;
        l.chartData.calPoints = r2;
        l.chartData.eachSpacing = o2;
        drawYAxis(c, l, n, s);
        if (l.enableMarkLine !== false && e2 === 1) {
          drawMarkLine(l, n, s);
        }
        drawLegend(l.series, l, n, s, l.chartData);
        drawToolTipBridge(l, n, s, e2);
        drawCanvas(l, s);
      }, onAnimationFinish: function t13() {
        h.uevent.trigger("renderComplete");
      } });
      break;
    case "mix":
      this.animationInstance = new Animation({ timing: l.timing, duration: e, onProcess: function t13(e2) {
        s.clearRect(0, 0, l.width, l.height);
        if (l.rotate) {
          contextRotate(s, l);
        }
        drawYAxisGrid(d, l, n, s);
        drawXAxis(d, l, n, s);
        var a2 = drawMixDataPoints(c, l, n, s, e2), i2 = a2.xAxisPoints, r2 = a2.calPoints, o2 = a2.eachSpacing;
        l.chartData.xAxisPoints = i2;
        l.chartData.calPoints = r2;
        l.chartData.eachSpacing = o2;
        drawYAxis(c, l, n, s);
        if (l.enableMarkLine !== false && e2 === 1) {
          drawMarkLine(l, n, s);
        }
        drawLegend(l.series, l, n, s, l.chartData);
        drawToolTipBridge(l, n, s, e2);
        drawCanvas(l, s);
      }, onAnimationFinish: function t13() {
        h.uevent.trigger("renderComplete");
      } });
      break;
    case "column":
      this.animationInstance = new Animation({ timing: l.timing, duration: e, onProcess: function t13(e2) {
        s.clearRect(0, 0, l.width, l.height);
        if (l.rotate) {
          contextRotate(s, l);
        }
        drawYAxisGrid(d, l, n, s);
        drawXAxis(d, l, n, s);
        var a2 = drawColumnDataPoints(c, l, n, s, e2), i2 = a2.xAxisPoints, r2 = a2.calPoints, o2 = a2.eachSpacing;
        l.chartData.xAxisPoints = i2;
        l.chartData.calPoints = r2;
        l.chartData.eachSpacing = o2;
        drawYAxis(c, l, n, s);
        if (l.enableMarkLine !== false && e2 === 1) {
          drawMarkLine(l, n, s);
        }
        drawLegend(l.series, l, n, s, l.chartData);
        drawToolTipBridge(l, n, s, e2);
        drawCanvas(l, s);
      }, onAnimationFinish: function t13() {
        h.uevent.trigger("renderComplete");
      } });
      break;
    case "mount":
      this.animationInstance = new Animation({ timing: l.timing, duration: e, onProcess: function t13(e2) {
        s.clearRect(0, 0, l.width, l.height);
        if (l.rotate) {
          contextRotate(s, l);
        }
        drawYAxisGrid(d, l, n, s);
        drawXAxis(d, l, n, s);
        var a2 = drawMountDataPoints(c, l, n, s, e2), i2 = a2.xAxisPoints, r2 = a2.calPoints, o2 = a2.eachSpacing;
        l.chartData.xAxisPoints = i2;
        l.chartData.calPoints = r2;
        l.chartData.eachSpacing = o2;
        drawYAxis(c, l, n, s);
        if (l.enableMarkLine !== false && e2 === 1) {
          drawMarkLine(l, n, s);
        }
        drawLegend(l.series, l, n, s, l.chartData);
        drawToolTipBridge(l, n, s, e2);
        drawCanvas(l, s);
      }, onAnimationFinish: function t13() {
        h.uevent.trigger("renderComplete");
      } });
      break;
    case "bar":
      this.animationInstance = new Animation({ timing: l.timing, duration: e, onProcess: function t13(e2) {
        s.clearRect(0, 0, l.width, l.height);
        if (l.rotate) {
          contextRotate(s, l);
        }
        drawXAxis(d, l, n, s);
        var a2 = drawBarDataPoints(c, l, n, s, e2), i2 = a2.yAxisPoints, r2 = a2.calPoints, o2 = a2.eachSpacing;
        l.chartData.yAxisPoints = i2;
        l.chartData.xAxisPoints = l.chartData.xAxisData.xAxisPoints;
        l.chartData.calPoints = r2;
        l.chartData.eachSpacing = o2;
        drawYAxis(c, l, n, s);
        if (l.enableMarkLine !== false && e2 === 1) {
          drawMarkLine(l, n, s);
        }
        drawLegend(l.series, l, n, s, l.chartData);
        drawToolTipBridge(l, n, s, e2);
        drawCanvas(l, s);
      }, onAnimationFinish: function t13() {
        h.uevent.trigger("renderComplete");
      } });
      break;
    case "area":
      this.animationInstance = new Animation({ timing: l.timing, duration: e, onProcess: function t13(e2) {
        s.clearRect(0, 0, l.width, l.height);
        if (l.rotate) {
          contextRotate(s, l);
        }
        drawYAxisGrid(d, l, n, s);
        drawXAxis(d, l, n, s);
        var a2 = drawAreaDataPoints(c, l, n, s, e2), i2 = a2.xAxisPoints, r2 = a2.calPoints, o2 = a2.eachSpacing;
        l.chartData.xAxisPoints = i2;
        l.chartData.calPoints = r2;
        l.chartData.eachSpacing = o2;
        drawYAxis(c, l, n, s);
        if (l.enableMarkLine !== false && e2 === 1) {
          drawMarkLine(l, n, s);
        }
        drawLegend(l.series, l, n, s, l.chartData);
        drawToolTipBridge(l, n, s, e2);
        drawCanvas(l, s);
      }, onAnimationFinish: function t13() {
        h.uevent.trigger("renderComplete");
      } });
      break;
    case "ring":
      this.animationInstance = new Animation({ timing: l.timing, duration: e, onProcess: function t13(e2) {
        s.clearRect(0, 0, l.width, l.height);
        if (l.rotate) {
          contextRotate(s, l);
        }
        l.chartData.pieData = drawPieDataPoints(c, l, n, s, e2);
        drawLegend(l.series, l, n, s, l.chartData);
        drawToolTipBridge(l, n, s, e2);
        drawCanvas(l, s);
      }, onAnimationFinish: function t13() {
        h.uevent.trigger("renderComplete");
      } });
      break;
    case "pie":
      this.animationInstance = new Animation({ timing: l.timing, duration: e, onProcess: function t13(e2) {
        s.clearRect(0, 0, l.width, l.height);
        if (l.rotate) {
          contextRotate(s, l);
        }
        l.chartData.pieData = drawPieDataPoints(c, l, n, s, e2);
        drawLegend(l.series, l, n, s, l.chartData);
        drawToolTipBridge(l, n, s, e2);
        drawCanvas(l, s);
      }, onAnimationFinish: function t13() {
        h.uevent.trigger("renderComplete");
      } });
      break;
    case "rose":
      this.animationInstance = new Animation({ timing: l.timing, duration: e, onProcess: function t13(e2) {
        s.clearRect(0, 0, l.width, l.height);
        if (l.rotate) {
          contextRotate(s, l);
        }
        l.chartData.pieData = drawRoseDataPoints(c, l, n, s, e2);
        drawLegend(l.series, l, n, s, l.chartData);
        drawToolTipBridge(l, n, s, e2);
        drawCanvas(l, s);
      }, onAnimationFinish: function t13() {
        h.uevent.trigger("renderComplete");
      } });
      break;
    case "radar":
      this.animationInstance = new Animation({ timing: l.timing, duration: e, onProcess: function t13(e2) {
        s.clearRect(0, 0, l.width, l.height);
        if (l.rotate) {
          contextRotate(s, l);
        }
        l.chartData.radarData = drawRadarDataPoints(c, l, n, s, e2);
        drawLegend(l.series, l, n, s, l.chartData);
        drawToolTipBridge(l, n, s, e2);
        drawCanvas(l, s);
      }, onAnimationFinish: function t13() {
        h.uevent.trigger("renderComplete");
      } });
      break;
    case "arcbar":
      this.animationInstance = new Animation({ timing: l.timing, duration: e, onProcess: function t13(e2) {
        s.clearRect(0, 0, l.width, l.height);
        if (l.rotate) {
          contextRotate(s, l);
        }
        l.chartData.arcbarData = drawArcbarDataPoints(c, l, n, s, e2);
        drawCanvas(l, s);
      }, onAnimationFinish: function t13() {
        h.uevent.trigger("renderComplete");
      } });
      break;
    case "gauge":
      this.animationInstance = new Animation({ timing: l.timing, duration: e, onProcess: function t13(e2) {
        s.clearRect(0, 0, l.width, l.height);
        if (l.rotate) {
          contextRotate(s, l);
        }
        l.chartData.gaugeData = drawGaugeDataPoints(d, c, l, n, s, e2);
        drawCanvas(l, s);
      }, onAnimationFinish: function t13() {
        h.uevent.trigger("renderComplete");
      } });
      break;
    case "candle":
      this.animationInstance = new Animation({ timing: l.timing, duration: e, onProcess: function t13(e2) {
        s.clearRect(0, 0, l.width, l.height);
        if (l.rotate) {
          contextRotate(s, l);
        }
        drawYAxisGrid(d, l, n, s);
        drawXAxis(d, l, n, s);
        var a2 = drawCandleDataPoints(c, x, l, n, s, e2), i2 = a2.xAxisPoints, r2 = a2.calPoints, o2 = a2.eachSpacing;
        l.chartData.xAxisPoints = i2;
        l.chartData.calPoints = r2;
        l.chartData.eachSpacing = o2;
        drawYAxis(c, l, n, s);
        if (l.enableMarkLine !== false && e2 === 1) {
          drawMarkLine(l, n, s);
        }
        if (x) {
          drawLegend(x, l, n, s, l.chartData);
        } else {
          drawLegend(l.series, l, n, s, l.chartData);
        }
        drawToolTipBridge(l, n, s, e2);
        drawCanvas(l, s);
      }, onAnimationFinish: function t13() {
        h.uevent.trigger("renderComplete");
      } });
      break;
  }
}
function uChartsEvent() {
  this.events = {};
}
uChartsEvent.prototype.addEventListener = function(t12, e) {
  this.events[t12] = this.events[t12] || [];
  this.events[t12].push(e);
};
uChartsEvent.prototype.delEventListener = function(t12) {
  this.events[t12] = [];
};
uChartsEvent.prototype.trigger = function() {
  for (var t12 = arguments.length, e = Array(t12), a = 0; a < t12; a++) {
    e[a] = arguments[a];
  }
  var i = e[0];
  var r = e.slice(1);
  if (!!this.events[i]) {
    this.events[i].forEach(function(t13) {
      try {
        t13.apply(null, r);
      } catch (t14) {
      }
    });
  }
};
var uCharts = function t11(a) {
  a.pix = a.pixelRatio ? a.pixelRatio : 1;
  a.fontSize = a.fontSize ? a.fontSize : 13;
  a.fontColor = a.fontColor ? a.fontColor : config.fontColor;
  if (a.background == "" || a.background == "none") {
    a.background = "#FFFFFF";
  }
  a.title = assign({}, a.title);
  a.subtitle = assign({}, a.subtitle);
  a.duration = a.duration ? a.duration : 1e3;
  a.yAxis = assign({}, { data: [], showTitle: false, disabled: false, disableGrid: false, gridSet: "number", splitNumber: 5, gridType: "solid", dashLength: 4 * a.pix, gridColor: "#cccccc", padding: 10, fontColor: "#666666" }, a.yAxis);
  a.xAxis = assign({}, { rotateLabel: false, rotateAngle: 45, disabled: false, disableGrid: false, splitNumber: 5, calibration: false, fontColor: "#666666", fontSize: 13, lineHeight: 20, marginTop: 0, gridType: "solid", dashLength: 4, scrollAlign: "left", boundaryGap: "center", axisLine: true, axisLineColor: "#cccccc", titleFontSize: 13, titleOffsetY: 0, titleOffsetX: 0, titleFontColor: "#666666" }, a.xAxis);
  a.xAxis.scrollPosition = a.xAxis.scrollAlign;
  a.legend = assign({}, { show: true, position: "bottom", float: "center", backgroundColor: "rgba(0,0,0,0)", borderColor: "rgba(0,0,0,0)", borderWidth: 0, padding: 5, margin: 5, itemGap: 10, fontSize: a.fontSize, lineHeight: a.fontSize, fontColor: a.fontColor, formatter: {}, hiddenColor: "#CECECE" }, a.legend);
  a.extra = assign({ tooltip: { legendShape: "auto" } }, a.extra);
  a.rotate = a.rotate ? true : false;
  a.animation = a.animation ? true : false;
  a.rotate = a.rotate ? true : false;
  a.canvas2d = a.canvas2d ? true : false;
  let e = assign({}, config);
  e.color = a.color ? a.color : e.color;
  if (a.type == "pie") {
    e.pieChartLinePadding = a.dataLabel === false ? 0 : a.extra.pie.labelWidth * a.pix || e.pieChartLinePadding * a.pix;
  }
  if (a.type == "ring") {
    e.pieChartLinePadding = a.dataLabel === false ? 0 : a.extra.ring.labelWidth * a.pix || e.pieChartLinePadding * a.pix;
  }
  if (a.type == "rose") {
    e.pieChartLinePadding = a.dataLabel === false ? 0 : a.extra.rose.labelWidth * a.pix || e.pieChartLinePadding * a.pix;
  }
  e.pieChartTextPadding = a.dataLabel === false ? 0 : e.pieChartTextPadding * a.pix;
  e.rotate = a.rotate;
  if (a.rotate) {
    let t12 = a.width;
    let e2 = a.height;
    a.width = e2;
    a.height = t12;
  }
  a.padding = a.padding ? a.padding : e.padding;
  e.yAxisWidth = config.yAxisWidth * a.pix;
  e.fontSize = a.fontSize * a.pix;
  e.titleFontSize = config.titleFontSize * a.pix;
  e.subtitleFontSize = config.subtitleFontSize * a.pix;
  if (!a.context) {
    throw new Error("[uCharts] 未获取到context！注意：v2.0版本后，需要自行获取canvas的绘图上下文并传入opts.context！");
  }
  this.context = a.context;
  if (!this.context.setTextAlign) {
    this.context.setStrokeStyle = function(t12) {
      return this.strokeStyle = t12;
    };
    this.context.setLineWidth = function(t12) {
      return this.lineWidth = t12;
    };
    this.context.setLineCap = function(t12) {
      return this.lineCap = t12;
    };
    this.context.setFontSize = function(t12) {
      return this.font = t12 + "px sans-serif";
    };
    this.context.setFillStyle = function(t12) {
      return this.fillStyle = t12;
    };
    this.context.setTextAlign = function(t12) {
      return this.textAlign = t12;
    };
    this.context.setTextBaseline = function(t12) {
      return this.textBaseline = t12;
    };
    this.context.setShadow = function(t12, e2, a2, i) {
      this.shadowColor = i;
      this.shadowOffsetX = t12;
      this.shadowOffsetY = e2;
      this.shadowBlur = a2;
    };
    this.context.draw = function() {
    };
  }
  if (!this.context.setLineDash) {
    this.context.setLineDash = function(t12) {
    };
  }
  a.chartData = {};
  this.uevent = new uChartsEvent();
  this.scrollOption = { currentOffset: 0, startTouchX: 0, distance: 0, lastMoveTime: 0 };
  this.opts = a;
  this.config = e;
  drawCharts.call(this, a.type, a, e, this.context);
};
uCharts.prototype.updateData = function() {
  let t12 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};
  this.opts = assign({}, this.opts, t12);
  this.opts.updateData = true;
  let c = t12.scrollPosition || "current";
  switch (c) {
    case "current":
      this.opts._scrollDistance_ = this.scrollOption.currentOffset;
      break;
    case "left":
      this.opts._scrollDistance_ = 0;
      this.scrollOption = { currentOffset: 0, startTouchX: 0, distance: 0, lastMoveTime: 0 };
      break;
    case "right":
      let t13 = calYAxisData(this.opts.series, this.opts, this.config, this.context), e = t13.yAxisWidth;
      this.config.yAxisWidth = e;
      let a = 0;
      let i = getXAxisPoints(this.opts.categories, this.opts, this.config), r = i.xAxisPoints, o = i.startX, n = i.endX, l = i.eachSpacing;
      let s = l * (r.length - 1);
      let h = n - o;
      a = h - s;
      this.scrollOption = { currentOffset: a, startTouchX: a, distance: 0, lastMoveTime: 0 };
      this.opts._scrollDistance_ = a;
      break;
  }
  drawCharts.call(this, this.opts.type, this.opts, this.config, this.context);
};
uCharts.prototype.zoom = function() {
  var t12 = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : this.opts.xAxis.itemCount;
  if (this.opts.enableScroll !== true) {
    console.log("[uCharts] 请启用滚动条后使用");
    return;
  }
  let e = Math.round(Math.abs(this.scrollOption.currentOffset) / this.opts.chartData.eachSpacing) + Math.round(this.opts.xAxis.itemCount / 2);
  this.opts.animation = false;
  this.opts.xAxis.itemCount = t12.itemCount;
  let a = calYAxisData(this.opts.series, this.opts, this.config, this.context), i = a.yAxisWidth;
  this.config.yAxisWidth = i;
  let r = 0;
  let o = getXAxisPoints(this.opts.categories, this.opts, this.config), h = o.xAxisPoints, c = o.startX, d = o.endX, n = o.eachSpacing;
  let x = n * e;
  let l = d - c;
  let s = l - n * (h.length - 1);
  r = l / 2 - x;
  if (r > 0) {
    r = 0;
  }
  if (r < s) {
    r = s;
  }
  this.scrollOption = { currentOffset: r, startTouchX: 0, distance: 0, lastMoveTime: 0 };
  calValidDistance(this, r, this.opts.chartData, this.config, this.opts);
  this.opts._scrollDistance_ = r;
  drawCharts.call(this, this.opts.type, this.opts, this.config, this.context);
};
uCharts.prototype.dobuleZoom = function(t12) {
  if (this.opts.enableScroll !== true) {
    console.log("[uCharts] 请启用滚动条后使用");
    return;
  }
  const a = t12.changedTouches;
  if (a.length < 2) {
    return;
  }
  for (var e = 0; e < a.length; e++) {
    a[e].x = a[e].x ? a[e].x : a[e].clientX;
    a[e].y = a[e].y ? a[e].y : a[e].clientY;
  }
  const i = [getTouches(a[0], this.opts, t12), getTouches(a[1], this.opts, t12)];
  const c = Math.abs(i[0].x - i[1].x);
  if (!this.scrollOption.moveCount) {
    let t13 = { changedTouches: [{ x: a[0].x, y: this.opts.area[0] / this.opts.pix + 2 }] };
    let e2 = { changedTouches: [{ x: a[1].x, y: this.opts.area[0] / this.opts.pix + 2 }] };
    if (this.opts.rotate) {
      t13 = { changedTouches: [{ x: this.opts.height / this.opts.pix - this.opts.area[0] / this.opts.pix - 2, y: a[0].y }] };
      e2 = { changedTouches: [{ x: this.opts.height / this.opts.pix - this.opts.area[0] / this.opts.pix - 2, y: a[1].y }] };
    }
    const s = this.getCurrentDataIndex(t13).index;
    const h = this.getCurrentDataIndex(e2).index;
    const v = Math.abs(s - h);
    this.scrollOption.moveCount = v;
    this.scrollOption.moveCurrent1 = Math.min(s, h);
    this.scrollOption.moveCurrent2 = Math.max(s, h);
    return;
  }
  let d = c / this.scrollOption.moveCount;
  let r = (this.opts.width - this.opts.area[1] - this.opts.area[3]) / d;
  r = r <= 2 ? 2 : r;
  r = r >= this.opts.categories.length ? this.opts.categories.length : r;
  this.opts.animation = false;
  this.opts.xAxis.itemCount = r;
  let o = 0;
  let n = getXAxisPoints(this.opts.categories, this.opts, this.config), x = n.xAxisPoints, f = n.startX, p = n.endX, l = n.eachSpacing;
  let u = l * this.scrollOption.moveCurrent1;
  let g = p - f;
  let y = g - l * (x.length - 1);
  o = -u + Math.min(i[0].x, i[1].x) - this.opts.area[3] - l;
  if (o > 0) {
    o = 0;
  }
  if (o < y) {
    o = y;
  }
  this.scrollOption.currentOffset = o;
  this.scrollOption.startTouchX = 0;
  this.scrollOption.distance = 0;
  calValidDistance(this, o, this.opts.chartData, this.config, this.opts);
  this.opts._scrollDistance_ = o;
  drawCharts.call(this, this.opts.type, this.opts, this.config, this.context);
};
uCharts.prototype.stopAnimation = function() {
  this.animationInstance && this.animationInstance.stop();
};
uCharts.prototype.addEventListener = function(t12, e) {
  this.uevent.addEventListener(t12, e);
};
uCharts.prototype.delEventListener = function(t12) {
  this.uevent.delEventListener(t12);
};
uCharts.prototype.getCurrentDataIndex = function(e) {
  var a = null;
  if (e.changedTouches) {
    a = e.changedTouches[0];
  } else {
    a = e.mp.changedTouches[0];
  }
  if (a) {
    let t12 = getTouches(a, this.opts, e);
    if (this.opts.type === "pie" || this.opts.type === "ring") {
      return findPieChartCurrentIndex({ x: t12.x, y: t12.y }, this.opts.chartData.pieData, this.opts);
    } else if (this.opts.type === "rose") {
      return findRoseChartCurrentIndex({ x: t12.x, y: t12.y }, this.opts.chartData.pieData, this.opts);
    } else if (this.opts.type === "radar") {
      return findRadarChartCurrentIndex({ x: t12.x, y: t12.y }, this.opts.chartData.radarData, this.opts.categories.length);
    } else if (this.opts.type === "funnel") {
      return findFunnelChartCurrentIndex({ x: t12.x, y: t12.y }, this.opts.chartData.funnelData);
    } else if (this.opts.type === "map") {
      return findMapChartCurrentIndex({ x: t12.x, y: t12.y }, this.opts);
    } else if (this.opts.type === "word") {
      return findWordChartCurrentIndex({ x: t12.x, y: t12.y }, this.opts.chartData.wordCloudData);
    } else if (this.opts.type === "bar") {
      return findBarChartCurrentIndex({ x: t12.x, y: t12.y }, this.opts.chartData.calPoints, this.opts, this.config, Math.abs(this.scrollOption.currentOffset));
    } else {
      return findCurrentIndex({ x: t12.x, y: t12.y }, this.opts.chartData.calPoints, this.opts, this.config, Math.abs(this.scrollOption.currentOffset));
    }
  }
  return -1;
};
uCharts.prototype.getLegendDataIndex = function(e) {
  var a = null;
  if (e.changedTouches) {
    a = e.changedTouches[0];
  } else {
    a = e.mp.changedTouches[0];
  }
  if (a) {
    let t12 = getTouches(a, this.opts, e);
    return findLegendIndex({ x: t12.x, y: t12.y }, this.opts.chartData.legendData);
  }
  return -1;
};
uCharts.prototype.touchLegend = function(t12) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var a = null;
  if (t12.changedTouches) {
    a = t12.changedTouches[0];
  } else {
    a = t12.mp.changedTouches[0];
  }
  if (a) {
    getTouches(a, this.opts, t12);
    var r = this.getLegendDataIndex(t12);
    if (r >= 0) {
      if (this.opts.type == "candle") {
        this.opts.seriesMA[r].show = !this.opts.seriesMA[r].show;
      } else {
        this.opts.series[r].show = !this.opts.series[r].show;
      }
      this.opts.animation = e.animation ? true : false;
      this.opts._scrollDistance_ = this.scrollOption.currentOffset;
      drawCharts.call(this, this.opts.type, this.opts, this.config, this.context);
    }
  }
};
uCharts.prototype.showToolTip = function(t12) {
  var e = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};
  var c = null;
  if (t12.changedTouches) {
    c = t12.changedTouches[0];
  } else {
    c = t12.mp.changedTouches[0];
  }
  if (!c) {
    console.log("[uCharts] 未获取到event坐标信息");
  }
  var a = getTouches(c, this.opts, t12);
  var d = this.scrollOption.currentOffset;
  var i = assign({}, this.opts, { _scrollDistance_: d, animation: false });
  if (this.opts.type === "line" || this.opts.type === "area" || this.opts.type === "column" || this.opts.type === "scatter" || this.opts.type === "bubble") {
    var r = this.getCurrentDataIndex(t12);
    var o = e.index == void 0 ? r.index : e.index;
    if (o > -1 || o.length > 0) {
      var n = getSeriesDataItem(this.opts.series, o, r.group);
      if (n.length !== 0) {
        var l = getToolTipData(n, this.opts, o, r.group, this.opts.categories, e), s = l.textList, h = l.offset;
        h.y = a.y;
        i.tooltip = { textList: e.textList !== void 0 ? e.textList : s, offset: e.offset !== void 0 ? e.offset : h, option: e, index: o, group: r.group };
      }
    }
    drawCharts.call(this, i.type, i, this.config, this.context);
  }
  if (this.opts.type === "mount") {
    var o = e.index == void 0 ? this.getCurrentDataIndex(t12).index : e.index;
    if (o > -1) {
      var i = assign({}, this.opts, { animation: false });
      var n = assign({}, i._series_[o]);
      var s = [{ text: e.formatter ? e.formatter(n, void 0, o, i) : n.name + ": " + n.data, color: n.color, legendShape: this.opts.extra.tooltip.legendShape == "auto" ? n.legendShape : this.opts.extra.tooltip.legendShape }];
      var h = { x: i.chartData.calPoints[o].x, y: a.y };
      i.tooltip = { textList: e.textList ? e.textList : s, offset: e.offset !== void 0 ? e.offset : h, option: e, index: o };
    }
    drawCharts.call(this, i.type, i, this.config, this.context);
  }
  if (this.opts.type === "bar") {
    var r = this.getCurrentDataIndex(t12);
    var o = e.index == void 0 ? r.index : e.index;
    if (o > -1 || o.length > 0) {
      var n = getSeriesDataItem(this.opts.series, o, r.group);
      if (n.length !== 0) {
        var l = getToolTipData(n, this.opts, o, r.group, this.opts.categories, e), s = l.textList, h = l.offset;
        h.x = a.x;
        i.tooltip = { textList: e.textList !== void 0 ? e.textList : s, offset: e.offset !== void 0 ? e.offset : h, option: e, index: o };
      }
    }
    drawCharts.call(this, i.type, i, this.config, this.context);
  }
  if (this.opts.type === "mix") {
    var r = this.getCurrentDataIndex(t12);
    var o = e.index == void 0 ? r.index : e.index;
    if (o > -1) {
      var d = this.scrollOption.currentOffset;
      var i = assign({}, this.opts, { _scrollDistance_: d, animation: false });
      var n = getSeriesDataItem(this.opts.series, o);
      if (n.length !== 0) {
        var x = getMixToolTipData(n, this.opts, o, this.opts.categories, e), s = x.textList, h = x.offset;
        h.y = a.y;
        i.tooltip = { textList: e.textList ? e.textList : s, offset: e.offset !== void 0 ? e.offset : h, option: e, index: o };
      }
    }
    drawCharts.call(this, i.type, i, this.config, this.context);
  }
  if (this.opts.type === "candle") {
    var r = this.getCurrentDataIndex(t12);
    var o = e.index == void 0 ? r.index : e.index;
    if (o > -1) {
      var d = this.scrollOption.currentOffset;
      var i = assign({}, this.opts, { _scrollDistance_: d, animation: false });
      var n = getSeriesDataItem(this.opts.series, o);
      if (n.length !== 0) {
        var l = getCandleToolTipData(this.opts.series[0].data, n, this.opts, o, this.opts.categories, this.opts.extra.candle), s = l.textList, h = l.offset;
        h.y = a.y;
        i.tooltip = { textList: e.textList ? e.textList : s, offset: e.offset !== void 0 ? e.offset : h, option: e, index: o };
      }
    }
    drawCharts.call(this, i.type, i, this.config, this.context);
  }
  if (this.opts.type === "pie" || this.opts.type === "ring" || this.opts.type === "rose" || this.opts.type === "funnel") {
    var o = e.index == void 0 ? this.getCurrentDataIndex(t12) : e.index;
    if (o > -1) {
      var i = assign({}, this.opts, { animation: false });
      var n = assign({}, i._series_[o]);
      var s = [{ text: e.formatter ? e.formatter(n, void 0, o, i) : n.name + ": " + n.data, color: n.color, legendShape: this.opts.extra.tooltip.legendShape == "auto" ? n.legendShape : this.opts.extra.tooltip.legendShape }];
      var h = { x: a.x, y: a.y };
      i.tooltip = { textList: e.textList ? e.textList : s, offset: e.offset !== void 0 ? e.offset : h, option: e, index: o };
    }
    drawCharts.call(this, i.type, i, this.config, this.context);
  }
  if (this.opts.type === "map") {
    var o = e.index == void 0 ? this.getCurrentDataIndex(t12) : e.index;
    if (o > -1) {
      var i = assign({}, this.opts, { animation: false });
      var n = assign({}, this.opts.series[o]);
      n.name = n.properties.name;
      var s = [{ text: e.formatter ? e.formatter(n, void 0, o, this.opts) : n.name, color: n.color, legendShape: this.opts.extra.tooltip.legendShape == "auto" ? n.legendShape : this.opts.extra.tooltip.legendShape }];
      var h = { x: a.x, y: a.y };
      i.tooltip = { textList: e.textList ? e.textList : s, offset: e.offset !== void 0 ? e.offset : h, option: e, index: o };
    }
    i.updateData = false;
    drawCharts.call(this, i.type, i, this.config, this.context);
  }
  if (this.opts.type === "word") {
    var o = e.index == void 0 ? this.getCurrentDataIndex(t12) : e.index;
    if (o > -1) {
      var i = assign({}, this.opts, { animation: false });
      var n = assign({}, this.opts.series[o]);
      var s = [{ text: e.formatter ? e.formatter(n, void 0, o, this.opts) : n.name, color: n.color, legendShape: this.opts.extra.tooltip.legendShape == "auto" ? n.legendShape : this.opts.extra.tooltip.legendShape }];
      var h = { x: a.x, y: a.y };
      i.tooltip = { textList: e.textList ? e.textList : s, offset: e.offset !== void 0 ? e.offset : h, option: e, index: o };
    }
    i.updateData = false;
    drawCharts.call(this, i.type, i, this.config, this.context);
  }
  if (this.opts.type === "radar") {
    var o = e.index == void 0 ? this.getCurrentDataIndex(t12) : e.index;
    if (o > -1) {
      var i = assign({}, this.opts, { animation: false });
      var n = getSeriesDataItem(this.opts.series, o);
      if (n.length !== 0) {
        var s = n.map((t13) => {
          return { text: e.formatter ? e.formatter(t13, this.opts.categories[o], o, this.opts) : t13.name + ": " + t13.data, color: t13.color, legendShape: this.opts.extra.tooltip.legendShape == "auto" ? t13.legendShape : this.opts.extra.tooltip.legendShape };
        });
        var h = { x: a.x, y: a.y };
        i.tooltip = { textList: e.textList ? e.textList : s, offset: e.offset !== void 0 ? e.offset : h, option: e, index: o };
      }
    }
    drawCharts.call(this, i.type, i, this.config, this.context);
  }
};
uCharts.prototype.translate = function(t12) {
  this.scrollOption = { currentOffset: t12, startTouchX: t12, distance: 0, lastMoveTime: 0 };
  let e = assign({}, this.opts, { _scrollDistance_: t12, animation: false });
  drawCharts.call(this, this.opts.type, e, this.config, this.context);
};
uCharts.prototype.scrollStart = function(t12) {
  var e = null;
  if (t12.changedTouches) {
    e = t12.changedTouches[0];
  } else {
    e = t12.mp.changedTouches[0];
  }
  var a = getTouches(e, this.opts, t12);
  if (e && this.opts.enableScroll === true) {
    this.scrollOption.startTouchX = a.x;
  }
};
uCharts.prototype.scroll = function(t12) {
  if (this.scrollOption.lastMoveTime === 0) {
    this.scrollOption.lastMoveTime = Date.now();
  }
  let e = this.opts.touchMoveLimit || 60;
  let a = Date.now();
  let i = a - this.scrollOption.lastMoveTime;
  if (i < Math.floor(1e3 / e))
    return;
  if (this.scrollOption.startTouchX == 0)
    return;
  this.scrollOption.lastMoveTime = a;
  var r = null;
  if (t12.changedTouches) {
    r = t12.changedTouches[0];
  } else {
    r = t12.mp.changedTouches[0];
  }
  if (r && this.opts.enableScroll === true) {
    var o = getTouches(r, this.opts, t12);
    var n;
    n = o.x - this.scrollOption.startTouchX;
    var l = this.scrollOption.currentOffset;
    var s = calValidDistance(this, l + n, this.opts.chartData, this.config, this.opts);
    this.scrollOption.distance = n = s - l;
    var h = assign({}, this.opts, { _scrollDistance_: l + n, animation: false });
    this.opts = h;
    drawCharts.call(this, h.type, h, this.config, this.context);
    return l + n;
  }
};
uCharts.prototype.scrollEnd = function(t12) {
  if (this.opts.enableScroll === true) {
    var e = this.scrollOption, a = e.currentOffset, i = e.distance;
    this.scrollOption.currentOffset = a + i;
    this.scrollOption.distance = 0;
    this.scrollOption.moveCount = 0;
  }
};
exports.uCharts = uCharts;
